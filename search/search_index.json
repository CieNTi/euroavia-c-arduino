{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de C y Arduino para Euroavia Sevilla Se dividir\u00e1 en las siguientes secciones: Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados Lenguaje C Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino Hardware Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller Arduino Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Home"},{"location":"#taller-de-c-y-arduino-para-euroavia-sevilla","text":"Se dividir\u00e1 en las siguientes secciones:","title":" Taller de C y Arduino para Euroavia Sevilla"},{"location":"#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"#lenguaje-c","text":"Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino","title":"Lenguaje C"},{"location":"#hardware","text":"Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller","title":"Hardware"},{"location":"#arduino","text":"Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Arduino"},{"location":"arduino/","text":"Introducci\u00f3n a Arduino TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/#introduccion-a-arduino","text":"TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/practica-01/","text":"Pr\u00e1ctica 1 TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-01/#practica-1","text":"TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-02/","text":"Pr\u00e1ctica 2 - El bus I2C Introducci\u00f3n Antes de comenzar, se debe entender el concepto de bus: En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. Wikipedia El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir dicha comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentaci\u00f3n, Vcc y GND, y dos espec\u00edficas, SCL (linea de reloj) y SDA (linea de datos). Esto mismo se representa en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No ser\u00e1 necesaria su lectura para la pr\u00e1ctica, pero no est\u00e1 de mas tener a mano la documentaci\u00f3n de cada parte para casos de duda, aprendizaje o pura curiosidad. Descargar I2C-bus specification and user manual (UM10204) Como continuar Lo siguiente ser\u00e1 informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraer\u00e1 todo el bajo nivel a modo de funciones incluidas mediante librer\u00edas. El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino. Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso. Dichas librerias pueden ser parte del conjunto est\u00e1ndar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librer\u00eda que da soporte Arduino al chip ESP8266 (de otro modo, no ser\u00eda posible trabajar con el entorno de Arduino y la placa proporcionada). Para poder usarlas es necesario leer su documentacion de antemano, que se compone de: Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Librerias de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. https://www.arduino.cc/en/Reference/Libraries Como se indica, se recomienda primero ver la parte espec\u00edfica y luego la general, ya que tendr\u00e1 preferencia en el momento de su uso. Esto pasa con la funcion Wire.begin() : Wire.begin() existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusi\u00f3n aunque el programa sea totalmente correcto. Lo correcto ser\u00e1 usar Wire.begin() como dicta la libreria del ESP8266: Wire.begin(SDA_pin, SCL_pin) . Esto arrancar\u00e1 el perif\u00e9rico I2C en modo maestro usando concr\u00e9tamente esos pines. Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usar\u00e1n como dicta la libreria Wire de Arduino. Pr\u00e1ctica En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con el dispositivo BME280 acoplado al D1 Mini. Para referencia, el montaje proporcionado equivale al siguiente esquem\u00e1tico: Primera comunicaci\u00f3n I2C Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* Start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no se llevar\u00e1 a cabo una comunicaci\u00f3n v\u00e1lida por no existir un esclavo con la direcci\u00f3n 0x12 , lo que deja la duda de .. entonces cual es la correcta? . Para responderla es necesario estudiar los dispositivos , documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante. Leer un byte En el caso del BME280, tras leer su datasheet , vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , seg\u00fan si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder. Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no est\u00e9n sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la funci\u00f3n Wire.available() . Incluyendo ambos cambios, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_available-byte.ino en GitHub El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- Received byte: 0x03 Ahoy! ESP8266 here! --- Received byte: 0x1E Ahoy! ESP8266 here! --- Received byte: 0x27 Ahoy! ESP8266 here! --- Received byte: 0x41 Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicar\u00e1 que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa autom\u00e1ticamente con cada lectura, y se reinicia llegado a un tope. Leer de una direcci\u00f3n concreta Si nos fijamos bien, en el ejemplo anterior no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato de una direcci\u00f3n concreta es necesario direccionarlo primero. De nuevo su datasheet detalla c\u00f3mo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas. Interpret\u00e1ndola, ser\u00e1 necesario: Hacer una escritura, en la que el dato enviado ser\u00e1 la direcci\u00f3n de la que queremos leer El BME280 internamente reposicionar\u00e1 su puntero de memoria. Entonces se procede a la lectura Ahora es cuando el BME280 devolver\u00e1 los datos almacenados a partir de la direcci\u00f3n pedida Si en lugar de varios queremos un \u00fanico byte, simplemente tendremos que pedir un \u00fanico byte . Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID , localizado en la direcci\u00f3n 0xD0 . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n Si todo esto se traduce a c\u00f3digo, lo visto quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(0x76); Wire.write(0xD0); Wire.endTransmission(); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_byte-addressing.ino en GitHub El programa deber\u00eda imprimir por puerto serie ex\u00e1ctamente lo siguiente: Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Que indicar\u00e1 que se ha le\u00eddo correctamente el identificador de chip, localizado en la direcci\u00f3n 0xD0 , con el valor esperado de 0x60 . Leer un bloque de memoria Siguiendo la misma linea del ejemplo anterior, lo l\u00f3gico ser\u00eda pensar en hacer varios Wire.read() y salvar el resultado, algo como: (...) /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 3); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c0 = Wire.read(); uint8_t c1 = Wire.read(); uint8_t c2 = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received bytes: 0x%02X, 0x%02X and 0x%02X\\n\", c0, c1, c2); } (...) Pero resulta un m\u00e9todo tedioso y muy poco eficiente, en el que un bloque simple de 128 bytes ser\u00eda un programa enorme para una tarea muy sencilla. En este momento entran en juego los arrays , que son matrices compuestas por un numero finito de elementos de alg\u00fan tipo definido. Para este caso se deber\u00e1 usar un array de elementos de tipo uint8_t . Junto al array, se utilizar\u00e1 una variable secundaria que servir\u00e1 de \u00edndice para almacenar la posici\u00f3n dentro del array donde se salvar\u00e1 el siguiente dato. Esta variable comenzar\u00e1 siendo 0 y se incrementar\u00e1 cada vez que se reciba un dato. Ahora queda saber desde qu\u00e9 direcci\u00f3n comenzar a leer, y para esto el datasheet proporciona el mapa de registros en memoria y sus direcciones, como se ve en la siguiente figura: Como se puede observar, el primer dato se encuentra en la direcci\u00f3n 0x88 y el \u00faltimo en la 0xFE , sumando un total de 118 bytes. Arduino tiene un limite interno para Wire.requestFrom() de 128 bytes , y como se necesitan s\u00f3lo 118 no deber\u00eda haber problema, pero hay que tenerlo en cuenta en caso de necesitarse transferencias de mayor tama\u00f1o, ya que habr\u00eda que fraccionarlas. Llevado a c\u00f3digo, el nuevo programa podr\u00eda quedar como sigue: /* Include required headers and/or libraries */ #include <Wire.h> #define SLAVE_ADDRESS 0x76 #define BLOCK_ADDRESS 0x88 #define BLOCK_LENGTH 118 /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(SLAVE_ADDRESS); Wire.write(BLOCK_ADDRESS); Wire.endTransmission(); /* Use static to prevent block re-allocation on each pass */ static uint8_t memory_map[BLOCK_LENGTH] = { 0x00 }; /* Array index, stores position to write a received byte */ uint8_t memory_idx = 0; /* Used to check the received amount */ uint8_t rx_bytes = 0; /* Request data from slave */ Wire.requestFrom(SLAVE_ADDRESS, BLOCK_LENGTH); /* Wait for data to be available */ while (rx_bytes == 0) { rx_bytes = Wire.available(); } /* Save the block */ for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { memory_map[memory_idx] = Wire.read(); } /* Print the block */ Serial.printf(\" ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n\"); Serial.printf(\"----+------------------------------------------------\"); for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { /* Create a new line each 16 printed bytes */ if ((memory_idx % 16) == 0) { Serial.printf(\"\\n %02X |\", memory_idx + BLOCK_ADDRESS); } /* Print a byte */ Serial.printf(\" %02X\", memory_map[memory_idx]); } Serial.printf(\"\\nEnd of data\\n\"); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_block-read.ino en GitHub En este ejemplo se ha incluido el uso de macros de precompilacion, como por ejemplo pasa con #define BLOCK_LENGTH 118 . Esto crea BLOCK_LENGTH , que parece y funciona como una variable ya que se sustituye por el numero 118, pero que se sustituye antes de compilar el programa, por lo que es como si se escribiera el numero 118 en el propio c\u00f3digo. Macro frente a Variable: La diferencia es que al tratarse de un valor constante, pues 118 no cambiar\u00e1 nunca a lo largo del programa, usar una variable para esto es un malgasto de memoria RAM. Macro frente a N\u00famero: La diferencia es que el uso de un nombre descriptivo frente a un simple numero siempre ser\u00e1 mas claro de leer y de entender. El uso de n\u00fameros sin descripci\u00f3n es una mala pr\u00e1ctica, y debe evitarse siempre que sea posible. Se conoce tambien como \u2018hardcoding\u2019 o \u2018magic numbers\u2019: In computer programming, the term magic number has multiple meanings. It could refer to one or more of the following: Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants A constant numerical or text value used to identify a file format or protocol; for files, see List of file signatures Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., Globally Unique Identifiers) Wikipedia El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Como puede comprobarse, el Chip ID puede leerse como 60 en la posici\u00f3n con fila C8 y columna 08 (que se corresponde a 0xC8 + 0x08 = 0xD0 , la direcci\u00f3n del Chip ID).","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#practica-2-el-bus-i2c","text":"","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#introduccion","text":"Antes de comenzar, se debe entender el concepto de bus: En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. Wikipedia El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir dicha comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentaci\u00f3n, Vcc y GND, y dos espec\u00edficas, SCL (linea de reloj) y SDA (linea de datos). Esto mismo se representa en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No ser\u00e1 necesaria su lectura para la pr\u00e1ctica, pero no est\u00e1 de mas tener a mano la documentaci\u00f3n de cada parte para casos de duda, aprendizaje o pura curiosidad. Descargar I2C-bus specification and user manual (UM10204)","title":"Introducci\u00f3n"},{"location":"arduino/practica-02/#como-continuar","text":"Lo siguiente ser\u00e1 informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraer\u00e1 todo el bajo nivel a modo de funciones incluidas mediante librer\u00edas. El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino. Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso. Dichas librerias pueden ser parte del conjunto est\u00e1ndar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librer\u00eda que da soporte Arduino al chip ESP8266 (de otro modo, no ser\u00eda posible trabajar con el entorno de Arduino y la placa proporcionada). Para poder usarlas es necesario leer su documentacion de antemano, que se compone de: Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Librerias de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. https://www.arduino.cc/en/Reference/Libraries Como se indica, se recomienda primero ver la parte espec\u00edfica y luego la general, ya que tendr\u00e1 preferencia en el momento de su uso. Esto pasa con la funcion Wire.begin() : Wire.begin() existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusi\u00f3n aunque el programa sea totalmente correcto. Lo correcto ser\u00e1 usar Wire.begin() como dicta la libreria del ESP8266: Wire.begin(SDA_pin, SCL_pin) . Esto arrancar\u00e1 el perif\u00e9rico I2C en modo maestro usando concr\u00e9tamente esos pines. Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usar\u00e1n como dicta la libreria Wire de Arduino.","title":"Como continuar"},{"location":"arduino/practica-02/#practica","text":"En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con el dispositivo BME280 acoplado al D1 Mini. Para referencia, el montaje proporcionado equivale al siguiente esquem\u00e1tico:","title":"Pr\u00e1ctica"},{"location":"arduino/practica-02/#primera-comunicacion-i2c","text":"Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* Start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no se llevar\u00e1 a cabo una comunicaci\u00f3n v\u00e1lida por no existir un esclavo con la direcci\u00f3n 0x12 , lo que deja la duda de .. entonces cual es la correcta? . Para responderla es necesario estudiar los dispositivos , documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante.","title":"Primera comunicaci\u00f3n I2C"},{"location":"arduino/practica-02/#leer-un-byte","text":"En el caso del BME280, tras leer su datasheet , vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , seg\u00fan si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder. Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no est\u00e9n sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la funci\u00f3n Wire.available() . Incluyendo ambos cambios, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_available-byte.ino en GitHub El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- Received byte: 0x03 Ahoy! ESP8266 here! --- Received byte: 0x1E Ahoy! ESP8266 here! --- Received byte: 0x27 Ahoy! ESP8266 here! --- Received byte: 0x41 Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicar\u00e1 que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa autom\u00e1ticamente con cada lectura, y se reinicia llegado a un tope.","title":"Leer un byte"},{"location":"arduino/practica-02/#leer-de-una-direccion-concreta","text":"Si nos fijamos bien, en el ejemplo anterior no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato de una direcci\u00f3n concreta es necesario direccionarlo primero. De nuevo su datasheet detalla c\u00f3mo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas. Interpret\u00e1ndola, ser\u00e1 necesario: Hacer una escritura, en la que el dato enviado ser\u00e1 la direcci\u00f3n de la que queremos leer El BME280 internamente reposicionar\u00e1 su puntero de memoria. Entonces se procede a la lectura Ahora es cuando el BME280 devolver\u00e1 los datos almacenados a partir de la direcci\u00f3n pedida Si en lugar de varios queremos un \u00fanico byte, simplemente tendremos que pedir un \u00fanico byte . Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID , localizado en la direcci\u00f3n 0xD0 . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n Si todo esto se traduce a c\u00f3digo, lo visto quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(0x76); Wire.write(0xD0); Wire.endTransmission(); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_byte-addressing.ino en GitHub El programa deber\u00eda imprimir por puerto serie ex\u00e1ctamente lo siguiente: Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Que indicar\u00e1 que se ha le\u00eddo correctamente el identificador de chip, localizado en la direcci\u00f3n 0xD0 , con el valor esperado de 0x60 .","title":"Leer de una direcci\u00f3n concreta"},{"location":"arduino/practica-02/#leer-un-bloque-de-memoria","text":"Siguiendo la misma linea del ejemplo anterior, lo l\u00f3gico ser\u00eda pensar en hacer varios Wire.read() y salvar el resultado, algo como: (...) /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 3); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c0 = Wire.read(); uint8_t c1 = Wire.read(); uint8_t c2 = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received bytes: 0x%02X, 0x%02X and 0x%02X\\n\", c0, c1, c2); } (...) Pero resulta un m\u00e9todo tedioso y muy poco eficiente, en el que un bloque simple de 128 bytes ser\u00eda un programa enorme para una tarea muy sencilla. En este momento entran en juego los arrays , que son matrices compuestas por un numero finito de elementos de alg\u00fan tipo definido. Para este caso se deber\u00e1 usar un array de elementos de tipo uint8_t . Junto al array, se utilizar\u00e1 una variable secundaria que servir\u00e1 de \u00edndice para almacenar la posici\u00f3n dentro del array donde se salvar\u00e1 el siguiente dato. Esta variable comenzar\u00e1 siendo 0 y se incrementar\u00e1 cada vez que se reciba un dato. Ahora queda saber desde qu\u00e9 direcci\u00f3n comenzar a leer, y para esto el datasheet proporciona el mapa de registros en memoria y sus direcciones, como se ve en la siguiente figura: Como se puede observar, el primer dato se encuentra en la direcci\u00f3n 0x88 y el \u00faltimo en la 0xFE , sumando un total de 118 bytes. Arduino tiene un limite interno para Wire.requestFrom() de 128 bytes , y como se necesitan s\u00f3lo 118 no deber\u00eda haber problema, pero hay que tenerlo en cuenta en caso de necesitarse transferencias de mayor tama\u00f1o, ya que habr\u00eda que fraccionarlas. Llevado a c\u00f3digo, el nuevo programa podr\u00eda quedar como sigue: /* Include required headers and/or libraries */ #include <Wire.h> #define SLAVE_ADDRESS 0x76 #define BLOCK_ADDRESS 0x88 #define BLOCK_LENGTH 118 /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(SLAVE_ADDRESS); Wire.write(BLOCK_ADDRESS); Wire.endTransmission(); /* Use static to prevent block re-allocation on each pass */ static uint8_t memory_map[BLOCK_LENGTH] = { 0x00 }; /* Array index, stores position to write a received byte */ uint8_t memory_idx = 0; /* Used to check the received amount */ uint8_t rx_bytes = 0; /* Request data from slave */ Wire.requestFrom(SLAVE_ADDRESS, BLOCK_LENGTH); /* Wait for data to be available */ while (rx_bytes == 0) { rx_bytes = Wire.available(); } /* Save the block */ for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { memory_map[memory_idx] = Wire.read(); } /* Print the block */ Serial.printf(\" ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n\"); Serial.printf(\"----+------------------------------------------------\"); for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { /* Create a new line each 16 printed bytes */ if ((memory_idx % 16) == 0) { Serial.printf(\"\\n %02X |\", memory_idx + BLOCK_ADDRESS); } /* Print a byte */ Serial.printf(\" %02X\", memory_map[memory_idx]); } Serial.printf(\"\\nEnd of data\\n\"); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_block-read.ino en GitHub En este ejemplo se ha incluido el uso de macros de precompilacion, como por ejemplo pasa con #define BLOCK_LENGTH 118 . Esto crea BLOCK_LENGTH , que parece y funciona como una variable ya que se sustituye por el numero 118, pero que se sustituye antes de compilar el programa, por lo que es como si se escribiera el numero 118 en el propio c\u00f3digo. Macro frente a Variable: La diferencia es que al tratarse de un valor constante, pues 118 no cambiar\u00e1 nunca a lo largo del programa, usar una variable para esto es un malgasto de memoria RAM. Macro frente a N\u00famero: La diferencia es que el uso de un nombre descriptivo frente a un simple numero siempre ser\u00e1 mas claro de leer y de entender. El uso de n\u00fameros sin descripci\u00f3n es una mala pr\u00e1ctica, y debe evitarse siempre que sea posible. Se conoce tambien como \u2018hardcoding\u2019 o \u2018magic numbers\u2019: In computer programming, the term magic number has multiple meanings. It could refer to one or more of the following: Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants A constant numerical or text value used to identify a file format or protocol; for files, see List of file signatures Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., Globally Unique Identifiers) Wikipedia El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Como puede comprobarse, el Chip ID puede leerse como 60 en la posici\u00f3n con fila C8 y columna 08 (que se corresponde a 0xC8 + 0x08 = 0xD0 , la direcci\u00f3n del Chip ID).","title":"Leer un bloque de memoria"},{"location":"arduino/practica-03/","text":"Pr\u00e1ctica 3 - Uso de librer\u00edas Tras aprender lo que es el bus I2C y como acceder a los datos en bruto de un dispositivo, en esta pr\u00e1ctica se usar\u00e1 una libreria para que haga ese mismo trabajo. Esto supone una primera ventaja clara: en lugar de necesitar saber los pormenores de un chip, ahora solo ser\u00e1 necesario saber c\u00f3mo se usan las funciones de una librer\u00eda. Introducci\u00f3n Una libreria es uno o varios ficheros de c\u00f3digo en donde ya hay programadas ciertas funcionalidades y se incluyen en el c\u00f3digo en forma de paquete, lo que: Simplificar\u00e1 enormemente el proceso de desarrollo Incrementar\u00e1 la calidad y legibilidad del c\u00f3digo final Necesitar\u00e1 de mucho menos tiempo para obtener los mismos resultados Evitar\u00e1 errores innecesarios, pues normalmente han pasado muchas pruebas Si una libreria falla suele haber alternativas Aunque no se haya estudiado en profundidad, esto ya se ha utilizado en los programas del taller en el momento que se usa, por ejemplo, #include <Wire.h> . Lo que realmente se est\u00e1 haciendo es incluir la cabecera de la librer\u00eda Wire , que dar\u00e1 a conocer al programa una serie de variables, funciones, clases, etc. De esta forma pasan a estar disponibles, y por lo tanto, su funcionalidad. Dicho de otro modo, la librer\u00eda Wire evita tener que leer uno o varios datasheets de un microcontrolador para saber c\u00f3mo hacer funcionar el bus I2C en su forma mas basica. Sin la libreria Wire ser\u00eda necesario programar funciones como Wire.requestFrom() o Wire.read() , lo que har\u00eda pr\u00e1cticamente inviable desarrollos a corto plazo. La siguiente figura muestra el modelo de capas de abstracci\u00f3n que se est\u00e1 usando: Para el caso del sensor BME280, supondr\u00eda una gran ventaja disponer de una librer\u00eda que ya hiciera todo el trabajo de pedir los datos y convertirlos, con tan solo definir los par\u00e1metros b\u00e1sicos del bus I2C y direcci\u00f3n de esclavo \u2026 y es lo que se ver\u00e1 a continuaci\u00f3n. Como continuar Lo primero es buscar y estudiar las posibilidades, y para esto Arduino facilita la tarea mediante un gestor de librerias, al que se accede a trav\u00e9s de Herramientas > Gestor de librerias \u2026 , obteniendo algo como en la siguiente figura: Como se continuar\u00e1 con el sensor BME280, se pone como filtro de b\u00fasqueda, lo que resultar\u00e1 en algo como: Para la pr\u00e1ctica se ha seleccionado la de SparkFun Electronics , por ser una de las mas completas, configurables y robustas. Esto no significa que no se pueda buscar informaci\u00f3n del resto, probarlas, y sacar conclusiones propias. Pr\u00e1ctica Una vez visto el mecanismo de instalaci\u00f3n y uso de librer\u00edas, se proporcionan los siguientes ejemplos para cada parte interesante del dispositivo, con vistas a utilizar todos o parte de los elementos para la \u00faltima pr\u00e1ctica, donde se construir\u00e1 un nodo IoT WiFi completamente funcional. Se recomienda compilar, probar y salvar cada ejemplo, para asi ver las particularidades de cada uno, y tomar consciencia del trabajo que pueda necesitar unificar todo en un \u00fanico programa. BME280: Temperatura, Humedad, Presi\u00f3n, Altitud Resumen La libreria propuesta se encarga de todo el proceso de bajo nivel encargado de pedir los datos en bruto y procesarlos. El programador solo tendr\u00e1 que pedir los datos, obteniendolos ya convertidos y en float . Se instala desde el gestor de librerias interno de Arduino. Libreria Enlaces de inter\u00e9s SparkFun BME280 de SparkFun Electronics Repositorio Documentado con ejemplos Ejemplos C\u00f3digo fuente Ejemplo funcional /* Include required headers and/or libraries */ #include <Wire.h> #include \"SparkFunBME280.h\" #define SLAVE_ADDRESS 0x76 /* Instantiate a BME280 object called BME280_obj */ BME280 BME280_obj; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(0, 2); Wire.setClock(400000); /* Address the sensor */ BME280_obj.setI2CAddress(SLAVE_ADDRESS); /* Check communication before continue */ if (BME280_obj.beginI2C(Wire) == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } /* -- Configure the sensor -- * - Read the datasheet - */ /* Filter coefficient. | 0 to 4 is valid. | See 3.4.4 */ BME280_obj.setFilter(2); /* Time between readings. | 0 to 7 valid. | See table 27. */ BME280_obj.setStandbyTime(1); /* 0 disables temp sensing. | 0 to 16 are valid. | See table 24. */ BME280_obj.setTempOverSample(8); /* 0 disables pressure sensing. | 0 to 16 are valid. | See table 23. */ BME280_obj.setPressureOverSample(8); /* 0 disables humidity sensing. | 0 to 16 are valid. | See table 19. */ BME280_obj.setHumidityOverSample(8); /* MODE_SLEEP, MODE_FORCED, MODE_NORMAL is valid. | See 3.3 */ BME280_obj.setMode(MODE_NORMAL); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Read and print sensor data */ Serial.printf(\" - Temp.: %2.2f [C]\\n\", BME280_obj.readTempC()); Serial.printf(\" - Temp.: %2.2f [F]\\n\", BME280_obj.readTempF()); Serial.printf(\" - Hum..: %2.2f [%%]\\n\", BME280_obj.readFloatHumidity()); Serial.printf(\" - Pres.: %2.2f [Pa]\\n\", BME280_obj.readFloatPressure()); Serial.printf(\" - Alt..: %2.2f [m]\\n\", BME280_obj.readFloatAltitudeMeters()); Serial.printf(\" - Alt..: %2.2f [Ft]\\n\", BME280_obj.readFloatAltitudeFeet()); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Salida esperada Ahoy! ESP8266 here! --- - Temp.: 34.08 [C] - Temp.: 93.34 [F] - Hum..: 26.10 [%] - Pres.: 101292.66 [Pa] - Alt..: 2.69 [m] - Alt..: 8.83 [Ft] Ahoy! ESP8266 here! --- - Temp.: 34.05 [C] - Temp.: 93.29 [F] - Hum..: 26.04 [%] - Pres.: 101292.16 [Pa] - Alt..: 2.73 [m] - Alt..: 8.97 [Ft] MPU6050: Temperatura, Aceleraci\u00f3n, Rotaci\u00f3n Resumen La libreria propuesta se encarga de hacer el trabajo de bajo nivel de pedir datos y convertirlos, aunque queda para el programador la puesta a 0 y correcci\u00f3n de offset. Se han probado librerias en principio mas completas, pero que en el momento de la ejecuci\u00f3n fallaban o no conseguian una comunicaci\u00f3n adecuada con el sensor. Se instala desde el gestor de librerias interno de Arduino. Libreria Enlaces de inter\u00e9s MPU6050 de Electronic Cats Repositorio Documentado con ejemplos Ejemplos C\u00f3digo fuente Ejemplo funcional /* Include required headers and/or libraries */ #include <Wire.h> #include <I2Cdev.h> #include <MPU6050.h> #define MPU6050_ADDRESS 0x68 /* Instantiate a MPU6050 object called MPU6050_obj */ MPU6050 accelgyro(MPU6050_ADDRESS); /* Used to translate from digital to human */ struct meas_range { uint16_t ranges[4]; uint8_t current; } MPU6050_range[2] = { { .ranges = { 250, 500, 1000, 2000 }, .current = 0 }, { .ranges = { 2, 4, 8, 16 }, .current = 0 }, }; #define RANGE_GYRO 0 #define RANGE_ACCEL 1 /* Get a gyro or accel raw value and convert to human-readable */ float raw_to_human(struct meas_range *range, int16_t raw_val) { /* Uncomment to get details about conversion */ //printf(\"Converting 0x%04X\\n\" // \" - %s range, current %u, value %u\\n\" // \" - Converted value %2.2f\\n\", // raw_val, // (range == &MPU6050_range[0])?\" Gyro\":\"Accel\", // range->current, range->ranges[range->current], // (((float)raw_val * range->ranges[range->current]) / 0x7FFF) // ); return (((float)raw_val * range->ranges[range->current]) / 0x7FFF); } /* Convert a temperature value, method differs from gyro/accel */ float temp_to_human(int16_t raw_val) { return (((float)raw_val / 340) + 36.53); } /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(); Wire.setClock(400000); /* Initialize the sensor */ accelgyro.initialize(); /* Check communication before continue */ if (accelgyro.testConnection() == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } /* By default, the library uses the following settings: * - setFullScaleGyroRange(MPU6050_GYRO_FS_250) * - setFullScaleAccelRange(MPU6050_ACCEL_FS_2) */ /* Configure Gyroscope range, choose from: * - MPU6050_GYRO_FS_250 ..: +/-250 deg/sec * - MPU6050_GYRO_FS_500 ..: +/-500 deg/sec * - MPU6050_GYRO_FS_1000 .: +/-1000 deg/sec * - MPU6050_GYRO_FS_2000 .: +/-2000 deg/sec * * Uncomment the following two lines to set a different value */ //MPU6050_range[RANGE_GYRO].current = MPU6050_GYRO_FS_2000; //accelgyro.setFullScaleGyroRange(MPU6050_range[RANGE_GYRO].current); /* Configure Accelerometer range, choose from: * - MPU6050_ACCEL_FS_2 ...: +/-2g * - MPU6050_ACCEL_FS_4 ...: +/-4g * - MPU6050_ACCEL_FS_8 ...: +/-8g * - MPU6050_ACCEL_FS_16 ..: +/-16g * * Uncomment the following two lines to set a different value */ //MPU6050_range[RANGE_ACCEL].current = MPU6050_ACCEL_FS_16; //accelgyro.setFullScaleAccelRange(MPU6050_range[RANGE_ACCEL].current); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Read and print sensor data */ Serial.printf(\" - Temperature ....: %2.2f [degC]\\n\", temp_to_human(accelgyro.getTemperature())); Serial.printf(\" - Rotation X .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationX())); Serial.printf(\" - Rotation Y .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationY())); Serial.printf(\" - Rotation Z .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationZ())); Serial.printf(\" - Acceleration X .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationX())); Serial.printf(\" - Acceleration Y .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationY())); Serial.printf(\" - Acceleration Z .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationZ())); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Salida esperada NOTA: Sin haberse corregido los offsets, los datos obtenidos pueden no tener sentido, pero lo importante de esta prueba es que varien con coherencia cuando se mueva la placa. La temperatura tambien subira o bajara, aunque en fracciones coherentes. Si los datos no var\u00edan, el sensor no se est\u00e1 midiendo correctamente. Ahoy! ESP8266 here! --- - Temperature ....: 32.81 [degC] - Rotation X .....: 0.24 [deg/sec] - Rotation Y .....: 3.66 [deg/sec] - Rotation Z .....: -3.87 [deg/sec] - Acceleration X .: 0.08 [g] - Acceleration Y .: -0.19 [g] - Acceleration Z .: 0.83 [g] Ahoy! ESP8266 here! --- - Temperature ....: 32.86 [degC] - Rotation X .....: 0.10 [deg/sec] - Rotation Y .....: 3.27 [deg/sec] - Rotation Z .....: -3.88 [deg/sec] - Acceleration X .: 0.08 [g] - Acceleration Y .: -0.19 [g] - Acceleration Z .: 0.83 [g] SPIFFS: Ficheros en memoria interna Resumen Esta librer\u00eda se encarga de todo el proceso de preparaci\u00f3n y uso de una parte de la flash como espacio de almacenamiento de ficheros. Un caso habitual es la necesidad de salvar informaci\u00f3n para acceder a ella en otro momento. Se suelen usar chips EEPROM o Flash, o dispositivos externos de almacenamiento, como pendrives. SPIFFS surge como una soluci\u00f3n para poder compartir el mismo espacio de almacenamiento que se usa para el programa, pero para el uso indiscriminado como almacenamiento de ficheros, lo que ahorra la necesidad de un chip extra, simplificando tanto el circuito como el programa finales. NOTA: Es necesario configurar Arduino para que asigne algo de espacio para SPIFFS. Esto se hace en la configuraci\u00f3n de la placa, donde se usar\u00e1 la opcion de 1 Mb para Programa y 3 Mb para SPIFFS , ya que inicialmente el programa no llegar\u00e1 a ocupar 1 Mb. En caso de ser asi, sera necesario modificar esta opci\u00f3n. NOTA: Es posible que tras programar la placa, esta no se arranque bien y quede en un estado err\u00e1tico. S\u00f3lo se deber\u00e1 resetear con el pulsador lateral, y esperar el mensaje Initializing SPIFFS . El primer arranque podr\u00e1 tardar bastante , ya que est\u00e1 preparando el espacio, pero a partir del segundo arranque, todo ser\u00e1 casi instant\u00e1neo. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s FS de Ivan Grokhotkov Repositorio (FS.h) Documentaci\u00f3n Ejemplo C\u00f3digo fuente Ejemplo funcional /* Include required headers and/or libraries */ #include <FS.h> #define TESTFILE \"/test_file.txt\" /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Initialize the file system */ Serial.printf(\"Initializing SPIFFS\\n\"); if (SPIFFS.begin() == false) { Serial.printf(\"SPIFFS cannot be initialized\\n\"); /* Stop here (WDT will reset at some point) */ while(1) {}; } } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); File test_file; #define MY_STR_LEN 1024 uint8_t my_string[MY_STR_LEN]; uint16_t my_line = 0; /* The file already exist? */ if (SPIFFS.exists(TESTFILE)) { Serial.printf(\"File '\" TESTFILE \"'' IS found'\\n\"); } else { Serial.printf(\"File '\" TESTFILE \"'' NOT found'\\n\"); } /* Mode 'a+' create if not exists: * - Read from the beginning of the file * - Append new data at the end * * Useful for buffers ;) */ test_file = SPIFFS.open(TESTFILE, \"a+\"); if (!test_file) { /* Oh man, this is serious */ Serial.printf(\"Cannot open '\" TESTFILE \"'' for appending'\\n\"); } else { Serial.printf(\"Opened '\" TESTFILE \"'\\n\"); /* Opened, now put some (at the end of the file) */ Serial.printf(\"Filling file '\" TESTFILE \"' with some data\\n\"); test_file.printf(\"This is the first line\\n\"); test_file.printf(\"This is the second line\\n\"); test_file.printf(\"This is the third line\\n\"); test_file.close(); /* Mode 'r' create if not exists: * - Read from the beginning of the file * - Fails if file not exists * * Useful for safe readings without data modification */ test_file = SPIFFS.open(TESTFILE, \"r\"); Serial.printf(\"Reopened '\" TESTFILE \"' for reading\\n\"); Serial.printf(\"Contents of file '\" TESTFILE \"'\\n\"); my_line = 0; while (test_file.position() < test_file.size()) { test_file.readBytesUntil('\\n', my_string, MY_STR_LEN); Serial.printf(\"Line %03d: %s\\n\", my_line++, my_string); } /* Done, free/close the file */ test_file.close(); Serial.printf(\"Closed '\" TESTFILE \"'\\n\"); /* Remove the file */ SPIFFS.remove(TESTFILE); Serial.printf(\"Removed '\" TESTFILE \"'\\n\"); } /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } } Salida esperada Initializing SPIFFS Ahoy! ESP8266 here! --- File '/test_file.txt'' NOT found' Opened '/test_file.txt' Filling file '/test_file.txt' with some data Contents of file '/test_file.txt' Line 000: This is the first line Line 001: This is the second line Line 002: This is the third line Closed '/test_file.txt' Removed '/test_file.txt' Locking now WiFi: Conexi\u00f3n a red y petici\u00f3n HTTP usando TCP Resumen Esta libreria permite conectar el dispositivo a redes WiFi, y por tanto, a servidores mediante TCP, UDP, \u2026 Se tendr\u00e1 que definir la red a la que conectar, y su password. Una vez est\u00e9 el dispositivo conectado se podr\u00e1 comenzar una conexi\u00f3n TCP, como se muestra en el ejemplo. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s ESP8266WiFi.h Repositorio (ESP8266WiFi.h) Documentaci\u00f3n Ejemplos C\u00f3digo fuente Ejemplo funcional /* Include required headers and/or libraries */ #include <ESP8266WiFi.h> /* This block allows to be configured outside this code, but will use * the following information as default in case is not */ #if !defined(STASSID) #define STASSID \"IoTesla\" #define STAPSK \"euroavia2019\" #endif /* Create wifi network information variables*/ const char *ssid = STASSID; const char *password = STAPSK; /* Define the host and port to connect */ const char *host = \"192.168.1.1\"; const uint16_t port = 80; /* Data holder for received data */ #define RCV_DATA_MAX 1024 uint8_t rcv_data[RCV_DATA_MAX] = { 0x00 }; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Uncomment the following line to enable debug output */ //Serial.setDebugOutput(true); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Report information about WiFi status */ Serial.printf(\"Connecting to '%s' access point [\", ssid); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); /* Wait until connected */ while (WiFi.status() != WL_CONNECTED) { Serial.printf(\".\"); delay(250); } /* Ahoy! */ Serial.printf(\"]\\nConnected! Assigned IP: %s\\n\", WiFi.localIP().toString().c_str()); /* Explaining the conversion shown over here: * * localIP() returns a IPAddress class member * - toString() returns a String class member * - c_str() returns a C compliant string pointer */ } /* * Recurrent task, called forever */ void loop() { /* Now we're going to connect to a remote host using TCP */ Serial.printf(\"Connecting to %s:%i ... \", host, port); /* To create a TCP connection we need the WiFiClient class */ WiFiClient TCPClient; /* Try to connect */ if (!TCPClient.connect(host, port)) { Serial.printf(\"Failed!\\nRetrying in 5 seconds ...\\n\"); delay(5000); return; } Serial.printf(\"Done!\\n\"); /* Send a request * As the remote host is a web server, use a compliant HTTP request */ Serial.printf(\"Requesting /index.html\\n\"); if (TCPClient.connected()) { /* This is a common HTTP request (and uses \\r\\n instead of \\n) */ TCPClient.printf(\"GET /index.html HTTP/1.1\\r\\n\" \"Host: %s\\r\\n\" \"Accept: image/gif, image/jpeg, */*\\r\\n\" \"Accept-Language: en-us\\r\\n\" \"Accept-Encoding: gzip, deflate\\r\\n\" \"User-Agent: IoTesla/1.0\\r\\n\" \"\\r\\n\" \"\\r\\n\", host); } /* Wait for the data to arrive * Attention must be paid to this type of wait block, as it don't use * simple delay to wait for incoming data. It waits \"up to 5 seconds\", * but will stop as soon as the data is ready. */ /* Save current time in milliseconds */ unsigned long timeout = millis(); /* Wait until data is ready */ while (TCPClient.available() == 0) { /* Not yet ready, we waited for more than 5 seconds? */ if (millis() - timeout > 5000) { /* 5 seconds lapse is ended, reloop again after 10 seconds */ Serial.printf(\"Connection timeout, no response\\n\"); TCPClient.stop(); delay(10000); return; } } /* Show the server response over the serial connection */ Serial.printf(\"Response received:\\n\"); /* Print data while still available (pay attention to %s format) */ size_t rcv_bytes = 0; while (TCPClient.available()) { while (rcv_bytes = TCPClient.read(rcv_data, RCV_DATA_MAX)) { Serial.printf(\"Printing %i bytes ---\\n%.*s\\n---\\n\", rcv_bytes, rcv_bytes, rcv_data); } } /* Wrap-up and go! It's finished! */ Serial.printf(\"Closing connection. Reloop in 10 seconds ...\\n\"); TCPClient.stop(); /* Ensure not to flood with a huge amount of fast data */ delay(10000); } Salida esperada En el caso del router IoTesla usado en el taller, pueden darse dos situaciones: Cuando env\u00ede contenido o cuando s\u00f3lo mantenga la conexi\u00f3n. Manteniendo la conexi\u00f3n activa: Ahoy! ESP8266 here! --- Connecting to 'IoTesla' access point [........] Connected! Assigned IP: 192.168.1.245 Connecting to 192.168.1.1:80 ... Done! Requesting /index.html Response received: Printing 41 bytes --- HTTP/1.1 200 OK Connection: Keep-Alive --- Closing connection. Reloop in 10 seconds ... Contenido de /index.html : Ahoy! ESP8266 here! --- Connecting to 'IoTesla' access point [........] Connected! Assigned IP: 192.168.1.245 Connecting to 192.168.1.1:80 ... Done! Requesting /index.html Response received: Printing 577 bytes --- HTTP/1.1 200 OK Connection: Keep-Alive Keep-Alive: timeout=20 ETag: \"3dc-1ef-59e641ec\" Last-Modified: Tue, 17 Oct 2017 17:46:20 GMT Date: Wed, 10 Apr 2019 16:34:12 GMT Content-Type: text/html Content-Length: 495 <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\"> <head> <meta http-equiv=\"Cache-Control\" content=\"no-cache\" /> <meta http-equiv=\"refresh\" content=\"0; URL=/cgi-bin/luci\" /> </head> <body style=\"background-color: white\"> <a s --- Closing connection. Reloop in 10 seconds ... WiFiMulti: Conectividad entre redes Resumen Esta libreria incrementa las posibilidades de la libreria WiFi al automatizar el proceso de mantener la conectividad siempre que sea posible. Se encargar\u00e1 de intentar la conexion a una red y mantenerla, y en caso de perderse, repetira el proceso con otra de las redes configuradas, hasta que recupere la conectividad. El programador s\u00f3lo tendr\u00e1 que definir las redes que conocer\u00e1 el dispositivo, con sus passwords en caso de necesitarse, y luego llamar al metodo .run() en el loop principal para mantener actualizado el estado de la libreria. Esto facilitar\u00e1 la tarea de utilizarlo en el taller, en casa, en el trabajo \u2026 con solo configurar una sola vez las posibles redes que tendr\u00e1 disponibles en alg\u00fan momento. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s ESP8266WiFiMulti de Markus Sattler Repositorio (ESP8266WiFiMulti.h) Documentado en ejemplos Ejemplos C\u00f3digo fuente Ejemplo funcional /* Include required headers and/or libraries */ #include <ESP8266WiFi.h> #include <ESP8266WiFiMulti.h> /* Instantiate a ESP8266WiFiMulti object called WiFiMulti */ ESP8266WiFiMulti WiFiMulti; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Comment the following line to disable debug output */ Serial.setDebugOutput(true); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Ensure to work as Station (disables internal AP) */ WiFi.mode(WIFI_STA); /* Add your home/personal wifi here */ WiFiMulti.addAP(\"personal-wifi\", \"the_password\"); /* If not found, will try to connect to this one */ WiFiMulti.addAP(\"IoTesla\", \"euroavia2019\"); } /* * Recurrent task, called forever */ void loop() { /* Pass the control to WifiMulti so it can check the network */ switch (WiFiMulti.run()) { /* 'WiFiMulti.run()' returns a status code. * The following switch..case shows all the valid cases for didactic * purposes, but tipically is only checked one or two cases, if so. */ case WL_IDLE_STATUS: Serial.printf(\"Returned WL_IDLE_STATUS\\n\"); break; case WL_NO_SSID_AVAIL: Serial.printf(\"Returned WL_NO_SSID_AVAIL\\n\"); break; case WL_SCAN_COMPLETED: Serial.printf(\"Returned WL_SCAN_COMPLETED\\n\"); break; case WL_CONNECTED: Serial.printf(\"Returned WL_CONNECTED\\n\"); break; case WL_CONNECT_FAILED: Serial.printf(\"Returned WL_CONNECT_FAILED\\n\"); break; case WL_CONNECTION_LOST: Serial.printf(\"Returned WL_CONNECTION_LOST\\n\"); break; case WL_DISCONNECTED: Serial.printf(\"Returned WL_DISCONNECTED\\n\"); break; } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Salida esperada Ahoy! ESP8266 here! --- scandone Returned WL_DISCONNECTED Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL scandone scandone state: 0 -> 2 (b0) state: 2 -> 3 (0) state: 3 -> 5 (10) add 0 aid 3 cnt connected with IoTesla, channel 9 dhcp client start... ip:192.168.1.245,mask:255.255.255.0,gw:192.168.1.1 Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED","title":"Pr\u00e1ctica 3 - Uso de librer\u00edas"},{"location":"arduino/practica-03/#practica-3-uso-de-librerias","text":"Tras aprender lo que es el bus I2C y como acceder a los datos en bruto de un dispositivo, en esta pr\u00e1ctica se usar\u00e1 una libreria para que haga ese mismo trabajo. Esto supone una primera ventaja clara: en lugar de necesitar saber los pormenores de un chip, ahora solo ser\u00e1 necesario saber c\u00f3mo se usan las funciones de una librer\u00eda.","title":"Pr\u00e1ctica 3 - Uso de librer\u00edas"},{"location":"arduino/practica-03/#introduccion","text":"Una libreria es uno o varios ficheros de c\u00f3digo en donde ya hay programadas ciertas funcionalidades y se incluyen en el c\u00f3digo en forma de paquete, lo que: Simplificar\u00e1 enormemente el proceso de desarrollo Incrementar\u00e1 la calidad y legibilidad del c\u00f3digo final Necesitar\u00e1 de mucho menos tiempo para obtener los mismos resultados Evitar\u00e1 errores innecesarios, pues normalmente han pasado muchas pruebas Si una libreria falla suele haber alternativas Aunque no se haya estudiado en profundidad, esto ya se ha utilizado en los programas del taller en el momento que se usa, por ejemplo, #include <Wire.h> . Lo que realmente se est\u00e1 haciendo es incluir la cabecera de la librer\u00eda Wire , que dar\u00e1 a conocer al programa una serie de variables, funciones, clases, etc. De esta forma pasan a estar disponibles, y por lo tanto, su funcionalidad. Dicho de otro modo, la librer\u00eda Wire evita tener que leer uno o varios datasheets de un microcontrolador para saber c\u00f3mo hacer funcionar el bus I2C en su forma mas basica. Sin la libreria Wire ser\u00eda necesario programar funciones como Wire.requestFrom() o Wire.read() , lo que har\u00eda pr\u00e1cticamente inviable desarrollos a corto plazo. La siguiente figura muestra el modelo de capas de abstracci\u00f3n que se est\u00e1 usando: Para el caso del sensor BME280, supondr\u00eda una gran ventaja disponer de una librer\u00eda que ya hiciera todo el trabajo de pedir los datos y convertirlos, con tan solo definir los par\u00e1metros b\u00e1sicos del bus I2C y direcci\u00f3n de esclavo \u2026 y es lo que se ver\u00e1 a continuaci\u00f3n.","title":"Introducci\u00f3n"},{"location":"arduino/practica-03/#como-continuar","text":"Lo primero es buscar y estudiar las posibilidades, y para esto Arduino facilita la tarea mediante un gestor de librerias, al que se accede a trav\u00e9s de Herramientas > Gestor de librerias \u2026 , obteniendo algo como en la siguiente figura: Como se continuar\u00e1 con el sensor BME280, se pone como filtro de b\u00fasqueda, lo que resultar\u00e1 en algo como: Para la pr\u00e1ctica se ha seleccionado la de SparkFun Electronics , por ser una de las mas completas, configurables y robustas. Esto no significa que no se pueda buscar informaci\u00f3n del resto, probarlas, y sacar conclusiones propias.","title":"Como continuar"},{"location":"arduino/practica-03/#practica","text":"Una vez visto el mecanismo de instalaci\u00f3n y uso de librer\u00edas, se proporcionan los siguientes ejemplos para cada parte interesante del dispositivo, con vistas a utilizar todos o parte de los elementos para la \u00faltima pr\u00e1ctica, donde se construir\u00e1 un nodo IoT WiFi completamente funcional. Se recomienda compilar, probar y salvar cada ejemplo, para asi ver las particularidades de cada uno, y tomar consciencia del trabajo que pueda necesitar unificar todo en un \u00fanico programa.","title":"Pr\u00e1ctica"},{"location":"arduino/practica-03/#bme280-temperatura-humedad-presion-altitud","text":"","title":"BME280: Temperatura, Humedad, Presi\u00f3n, Altitud"},{"location":"arduino/practica-03/#resumen","text":"La libreria propuesta se encarga de todo el proceso de bajo nivel encargado de pedir los datos en bruto y procesarlos. El programador solo tendr\u00e1 que pedir los datos, obteniendolos ya convertidos y en float . Se instala desde el gestor de librerias interno de Arduino. Libreria Enlaces de inter\u00e9s SparkFun BME280 de SparkFun Electronics Repositorio Documentado con ejemplos Ejemplos C\u00f3digo fuente","title":"Resumen"},{"location":"arduino/practica-03/#ejemplo-funcional","text":"/* Include required headers and/or libraries */ #include <Wire.h> #include \"SparkFunBME280.h\" #define SLAVE_ADDRESS 0x76 /* Instantiate a BME280 object called BME280_obj */ BME280 BME280_obj; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(0, 2); Wire.setClock(400000); /* Address the sensor */ BME280_obj.setI2CAddress(SLAVE_ADDRESS); /* Check communication before continue */ if (BME280_obj.beginI2C(Wire) == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } /* -- Configure the sensor -- * - Read the datasheet - */ /* Filter coefficient. | 0 to 4 is valid. | See 3.4.4 */ BME280_obj.setFilter(2); /* Time between readings. | 0 to 7 valid. | See table 27. */ BME280_obj.setStandbyTime(1); /* 0 disables temp sensing. | 0 to 16 are valid. | See table 24. */ BME280_obj.setTempOverSample(8); /* 0 disables pressure sensing. | 0 to 16 are valid. | See table 23. */ BME280_obj.setPressureOverSample(8); /* 0 disables humidity sensing. | 0 to 16 are valid. | See table 19. */ BME280_obj.setHumidityOverSample(8); /* MODE_SLEEP, MODE_FORCED, MODE_NORMAL is valid. | See 3.3 */ BME280_obj.setMode(MODE_NORMAL); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Read and print sensor data */ Serial.printf(\" - Temp.: %2.2f [C]\\n\", BME280_obj.readTempC()); Serial.printf(\" - Temp.: %2.2f [F]\\n\", BME280_obj.readTempF()); Serial.printf(\" - Hum..: %2.2f [%%]\\n\", BME280_obj.readFloatHumidity()); Serial.printf(\" - Pres.: %2.2f [Pa]\\n\", BME280_obj.readFloatPressure()); Serial.printf(\" - Alt..: %2.2f [m]\\n\", BME280_obj.readFloatAltitudeMeters()); Serial.printf(\" - Alt..: %2.2f [Ft]\\n\", BME280_obj.readFloatAltitudeFeet()); /* Ensure not to flood with a huge amount of fast data */ delay(500); }","title":"Ejemplo funcional"},{"location":"arduino/practica-03/#salida-esperada","text":"Ahoy! ESP8266 here! --- - Temp.: 34.08 [C] - Temp.: 93.34 [F] - Hum..: 26.10 [%] - Pres.: 101292.66 [Pa] - Alt..: 2.69 [m] - Alt..: 8.83 [Ft] Ahoy! ESP8266 here! --- - Temp.: 34.05 [C] - Temp.: 93.29 [F] - Hum..: 26.04 [%] - Pres.: 101292.16 [Pa] - Alt..: 2.73 [m] - Alt..: 8.97 [Ft]","title":"Salida esperada"},{"location":"arduino/practica-03/#mpu6050-temperatura-aceleracion-rotacion","text":"","title":"MPU6050: Temperatura, Aceleraci\u00f3n, Rotaci\u00f3n"},{"location":"arduino/practica-03/#resumen_1","text":"La libreria propuesta se encarga de hacer el trabajo de bajo nivel de pedir datos y convertirlos, aunque queda para el programador la puesta a 0 y correcci\u00f3n de offset. Se han probado librerias en principio mas completas, pero que en el momento de la ejecuci\u00f3n fallaban o no conseguian una comunicaci\u00f3n adecuada con el sensor. Se instala desde el gestor de librerias interno de Arduino. Libreria Enlaces de inter\u00e9s MPU6050 de Electronic Cats Repositorio Documentado con ejemplos Ejemplos C\u00f3digo fuente","title":"Resumen"},{"location":"arduino/practica-03/#ejemplo-funcional_1","text":"/* Include required headers and/or libraries */ #include <Wire.h> #include <I2Cdev.h> #include <MPU6050.h> #define MPU6050_ADDRESS 0x68 /* Instantiate a MPU6050 object called MPU6050_obj */ MPU6050 accelgyro(MPU6050_ADDRESS); /* Used to translate from digital to human */ struct meas_range { uint16_t ranges[4]; uint8_t current; } MPU6050_range[2] = { { .ranges = { 250, 500, 1000, 2000 }, .current = 0 }, { .ranges = { 2, 4, 8, 16 }, .current = 0 }, }; #define RANGE_GYRO 0 #define RANGE_ACCEL 1 /* Get a gyro or accel raw value and convert to human-readable */ float raw_to_human(struct meas_range *range, int16_t raw_val) { /* Uncomment to get details about conversion */ //printf(\"Converting 0x%04X\\n\" // \" - %s range, current %u, value %u\\n\" // \" - Converted value %2.2f\\n\", // raw_val, // (range == &MPU6050_range[0])?\" Gyro\":\"Accel\", // range->current, range->ranges[range->current], // (((float)raw_val * range->ranges[range->current]) / 0x7FFF) // ); return (((float)raw_val * range->ranges[range->current]) / 0x7FFF); } /* Convert a temperature value, method differs from gyro/accel */ float temp_to_human(int16_t raw_val) { return (((float)raw_val / 340) + 36.53); } /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(); Wire.setClock(400000); /* Initialize the sensor */ accelgyro.initialize(); /* Check communication before continue */ if (accelgyro.testConnection() == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } /* By default, the library uses the following settings: * - setFullScaleGyroRange(MPU6050_GYRO_FS_250) * - setFullScaleAccelRange(MPU6050_ACCEL_FS_2) */ /* Configure Gyroscope range, choose from: * - MPU6050_GYRO_FS_250 ..: +/-250 deg/sec * - MPU6050_GYRO_FS_500 ..: +/-500 deg/sec * - MPU6050_GYRO_FS_1000 .: +/-1000 deg/sec * - MPU6050_GYRO_FS_2000 .: +/-2000 deg/sec * * Uncomment the following two lines to set a different value */ //MPU6050_range[RANGE_GYRO].current = MPU6050_GYRO_FS_2000; //accelgyro.setFullScaleGyroRange(MPU6050_range[RANGE_GYRO].current); /* Configure Accelerometer range, choose from: * - MPU6050_ACCEL_FS_2 ...: +/-2g * - MPU6050_ACCEL_FS_4 ...: +/-4g * - MPU6050_ACCEL_FS_8 ...: +/-8g * - MPU6050_ACCEL_FS_16 ..: +/-16g * * Uncomment the following two lines to set a different value */ //MPU6050_range[RANGE_ACCEL].current = MPU6050_ACCEL_FS_16; //accelgyro.setFullScaleAccelRange(MPU6050_range[RANGE_ACCEL].current); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Read and print sensor data */ Serial.printf(\" - Temperature ....: %2.2f [degC]\\n\", temp_to_human(accelgyro.getTemperature())); Serial.printf(\" - Rotation X .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationX())); Serial.printf(\" - Rotation Y .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationY())); Serial.printf(\" - Rotation Z .....: %2.2f [deg/sec]\\n\", raw_to_human(&MPU6050_range[RANGE_GYRO], accelgyro.getRotationZ())); Serial.printf(\" - Acceleration X .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationX())); Serial.printf(\" - Acceleration Y .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationY())); Serial.printf(\" - Acceleration Z .: %2.2f [g]\\n\", raw_to_human(&MPU6050_range[RANGE_ACCEL], accelgyro.getAccelerationZ())); /* Ensure not to flood with a huge amount of fast data */ delay(500); }","title":"Ejemplo funcional"},{"location":"arduino/practica-03/#salida-esperada_1","text":"NOTA: Sin haberse corregido los offsets, los datos obtenidos pueden no tener sentido, pero lo importante de esta prueba es que varien con coherencia cuando se mueva la placa. La temperatura tambien subira o bajara, aunque en fracciones coherentes. Si los datos no var\u00edan, el sensor no se est\u00e1 midiendo correctamente. Ahoy! ESP8266 here! --- - Temperature ....: 32.81 [degC] - Rotation X .....: 0.24 [deg/sec] - Rotation Y .....: 3.66 [deg/sec] - Rotation Z .....: -3.87 [deg/sec] - Acceleration X .: 0.08 [g] - Acceleration Y .: -0.19 [g] - Acceleration Z .: 0.83 [g] Ahoy! ESP8266 here! --- - Temperature ....: 32.86 [degC] - Rotation X .....: 0.10 [deg/sec] - Rotation Y .....: 3.27 [deg/sec] - Rotation Z .....: -3.88 [deg/sec] - Acceleration X .: 0.08 [g] - Acceleration Y .: -0.19 [g] - Acceleration Z .: 0.83 [g]","title":"Salida esperada"},{"location":"arduino/practica-03/#spiffs-ficheros-en-memoria-interna","text":"","title":"SPIFFS: Ficheros en memoria interna"},{"location":"arduino/practica-03/#resumen_2","text":"Esta librer\u00eda se encarga de todo el proceso de preparaci\u00f3n y uso de una parte de la flash como espacio de almacenamiento de ficheros. Un caso habitual es la necesidad de salvar informaci\u00f3n para acceder a ella en otro momento. Se suelen usar chips EEPROM o Flash, o dispositivos externos de almacenamiento, como pendrives. SPIFFS surge como una soluci\u00f3n para poder compartir el mismo espacio de almacenamiento que se usa para el programa, pero para el uso indiscriminado como almacenamiento de ficheros, lo que ahorra la necesidad de un chip extra, simplificando tanto el circuito como el programa finales. NOTA: Es necesario configurar Arduino para que asigne algo de espacio para SPIFFS. Esto se hace en la configuraci\u00f3n de la placa, donde se usar\u00e1 la opcion de 1 Mb para Programa y 3 Mb para SPIFFS , ya que inicialmente el programa no llegar\u00e1 a ocupar 1 Mb. En caso de ser asi, sera necesario modificar esta opci\u00f3n. NOTA: Es posible que tras programar la placa, esta no se arranque bien y quede en un estado err\u00e1tico. S\u00f3lo se deber\u00e1 resetear con el pulsador lateral, y esperar el mensaje Initializing SPIFFS . El primer arranque podr\u00e1 tardar bastante , ya que est\u00e1 preparando el espacio, pero a partir del segundo arranque, todo ser\u00e1 casi instant\u00e1neo. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s FS de Ivan Grokhotkov Repositorio (FS.h) Documentaci\u00f3n Ejemplo C\u00f3digo fuente","title":"Resumen"},{"location":"arduino/practica-03/#ejemplo-funcional_2","text":"/* Include required headers and/or libraries */ #include <FS.h> #define TESTFILE \"/test_file.txt\" /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Initialize the file system */ Serial.printf(\"Initializing SPIFFS\\n\"); if (SPIFFS.begin() == false) { Serial.printf(\"SPIFFS cannot be initialized\\n\"); /* Stop here (WDT will reset at some point) */ while(1) {}; } } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); File test_file; #define MY_STR_LEN 1024 uint8_t my_string[MY_STR_LEN]; uint16_t my_line = 0; /* The file already exist? */ if (SPIFFS.exists(TESTFILE)) { Serial.printf(\"File '\" TESTFILE \"'' IS found'\\n\"); } else { Serial.printf(\"File '\" TESTFILE \"'' NOT found'\\n\"); } /* Mode 'a+' create if not exists: * - Read from the beginning of the file * - Append new data at the end * * Useful for buffers ;) */ test_file = SPIFFS.open(TESTFILE, \"a+\"); if (!test_file) { /* Oh man, this is serious */ Serial.printf(\"Cannot open '\" TESTFILE \"'' for appending'\\n\"); } else { Serial.printf(\"Opened '\" TESTFILE \"'\\n\"); /* Opened, now put some (at the end of the file) */ Serial.printf(\"Filling file '\" TESTFILE \"' with some data\\n\"); test_file.printf(\"This is the first line\\n\"); test_file.printf(\"This is the second line\\n\"); test_file.printf(\"This is the third line\\n\"); test_file.close(); /* Mode 'r' create if not exists: * - Read from the beginning of the file * - Fails if file not exists * * Useful for safe readings without data modification */ test_file = SPIFFS.open(TESTFILE, \"r\"); Serial.printf(\"Reopened '\" TESTFILE \"' for reading\\n\"); Serial.printf(\"Contents of file '\" TESTFILE \"'\\n\"); my_line = 0; while (test_file.position() < test_file.size()) { test_file.readBytesUntil('\\n', my_string, MY_STR_LEN); Serial.printf(\"Line %03d: %s\\n\", my_line++, my_string); } /* Done, free/close the file */ test_file.close(); Serial.printf(\"Closed '\" TESTFILE \"'\\n\"); /* Remove the file */ SPIFFS.remove(TESTFILE); Serial.printf(\"Removed '\" TESTFILE \"'\\n\"); } /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } }","title":"Ejemplo funcional"},{"location":"arduino/practica-03/#salida-esperada_2","text":"Initializing SPIFFS Ahoy! ESP8266 here! --- File '/test_file.txt'' NOT found' Opened '/test_file.txt' Filling file '/test_file.txt' with some data Contents of file '/test_file.txt' Line 000: This is the first line Line 001: This is the second line Line 002: This is the third line Closed '/test_file.txt' Removed '/test_file.txt' Locking now","title":"Salida esperada"},{"location":"arduino/practica-03/#wifi-conexion-a-red-y-peticion-http-usando-tcp","text":"","title":"WiFi: Conexi\u00f3n a red y petici\u00f3n HTTP usando TCP"},{"location":"arduino/practica-03/#resumen_3","text":"Esta libreria permite conectar el dispositivo a redes WiFi, y por tanto, a servidores mediante TCP, UDP, \u2026 Se tendr\u00e1 que definir la red a la que conectar, y su password. Una vez est\u00e9 el dispositivo conectado se podr\u00e1 comenzar una conexi\u00f3n TCP, como se muestra en el ejemplo. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s ESP8266WiFi.h Repositorio (ESP8266WiFi.h) Documentaci\u00f3n Ejemplos C\u00f3digo fuente","title":"Resumen"},{"location":"arduino/practica-03/#ejemplo-funcional_3","text":"/* Include required headers and/or libraries */ #include <ESP8266WiFi.h> /* This block allows to be configured outside this code, but will use * the following information as default in case is not */ #if !defined(STASSID) #define STASSID \"IoTesla\" #define STAPSK \"euroavia2019\" #endif /* Create wifi network information variables*/ const char *ssid = STASSID; const char *password = STAPSK; /* Define the host and port to connect */ const char *host = \"192.168.1.1\"; const uint16_t port = 80; /* Data holder for received data */ #define RCV_DATA_MAX 1024 uint8_t rcv_data[RCV_DATA_MAX] = { 0x00 }; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Uncomment the following line to enable debug output */ //Serial.setDebugOutput(true); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Report information about WiFi status */ Serial.printf(\"Connecting to '%s' access point [\", ssid); WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); /* Wait until connected */ while (WiFi.status() != WL_CONNECTED) { Serial.printf(\".\"); delay(250); } /* Ahoy! */ Serial.printf(\"]\\nConnected! Assigned IP: %s\\n\", WiFi.localIP().toString().c_str()); /* Explaining the conversion shown over here: * * localIP() returns a IPAddress class member * - toString() returns a String class member * - c_str() returns a C compliant string pointer */ } /* * Recurrent task, called forever */ void loop() { /* Now we're going to connect to a remote host using TCP */ Serial.printf(\"Connecting to %s:%i ... \", host, port); /* To create a TCP connection we need the WiFiClient class */ WiFiClient TCPClient; /* Try to connect */ if (!TCPClient.connect(host, port)) { Serial.printf(\"Failed!\\nRetrying in 5 seconds ...\\n\"); delay(5000); return; } Serial.printf(\"Done!\\n\"); /* Send a request * As the remote host is a web server, use a compliant HTTP request */ Serial.printf(\"Requesting /index.html\\n\"); if (TCPClient.connected()) { /* This is a common HTTP request (and uses \\r\\n instead of \\n) */ TCPClient.printf(\"GET /index.html HTTP/1.1\\r\\n\" \"Host: %s\\r\\n\" \"Accept: image/gif, image/jpeg, */*\\r\\n\" \"Accept-Language: en-us\\r\\n\" \"Accept-Encoding: gzip, deflate\\r\\n\" \"User-Agent: IoTesla/1.0\\r\\n\" \"\\r\\n\" \"\\r\\n\", host); } /* Wait for the data to arrive * Attention must be paid to this type of wait block, as it don't use * simple delay to wait for incoming data. It waits \"up to 5 seconds\", * but will stop as soon as the data is ready. */ /* Save current time in milliseconds */ unsigned long timeout = millis(); /* Wait until data is ready */ while (TCPClient.available() == 0) { /* Not yet ready, we waited for more than 5 seconds? */ if (millis() - timeout > 5000) { /* 5 seconds lapse is ended, reloop again after 10 seconds */ Serial.printf(\"Connection timeout, no response\\n\"); TCPClient.stop(); delay(10000); return; } } /* Show the server response over the serial connection */ Serial.printf(\"Response received:\\n\"); /* Print data while still available (pay attention to %s format) */ size_t rcv_bytes = 0; while (TCPClient.available()) { while (rcv_bytes = TCPClient.read(rcv_data, RCV_DATA_MAX)) { Serial.printf(\"Printing %i bytes ---\\n%.*s\\n---\\n\", rcv_bytes, rcv_bytes, rcv_data); } } /* Wrap-up and go! It's finished! */ Serial.printf(\"Closing connection. Reloop in 10 seconds ...\\n\"); TCPClient.stop(); /* Ensure not to flood with a huge amount of fast data */ delay(10000); }","title":"Ejemplo funcional"},{"location":"arduino/practica-03/#salida-esperada_3","text":"En el caso del router IoTesla usado en el taller, pueden darse dos situaciones: Cuando env\u00ede contenido o cuando s\u00f3lo mantenga la conexi\u00f3n. Manteniendo la conexi\u00f3n activa: Ahoy! ESP8266 here! --- Connecting to 'IoTesla' access point [........] Connected! Assigned IP: 192.168.1.245 Connecting to 192.168.1.1:80 ... Done! Requesting /index.html Response received: Printing 41 bytes --- HTTP/1.1 200 OK Connection: Keep-Alive --- Closing connection. Reloop in 10 seconds ... Contenido de /index.html : Ahoy! ESP8266 here! --- Connecting to 'IoTesla' access point [........] Connected! Assigned IP: 192.168.1.245 Connecting to 192.168.1.1:80 ... Done! Requesting /index.html Response received: Printing 577 bytes --- HTTP/1.1 200 OK Connection: Keep-Alive Keep-Alive: timeout=20 ETag: \"3dc-1ef-59e641ec\" Last-Modified: Tue, 17 Oct 2017 17:46:20 GMT Date: Wed, 10 Apr 2019 16:34:12 GMT Content-Type: text/html Content-Length: 495 <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\"> <head> <meta http-equiv=\"Cache-Control\" content=\"no-cache\" /> <meta http-equiv=\"refresh\" content=\"0; URL=/cgi-bin/luci\" /> </head> <body style=\"background-color: white\"> <a s --- Closing connection. Reloop in 10 seconds ...","title":"Salida esperada"},{"location":"arduino/practica-03/#wifimulti-conectividad-entre-redes","text":"","title":"WiFiMulti: Conectividad entre redes"},{"location":"arduino/practica-03/#resumen_4","text":"Esta libreria incrementa las posibilidades de la libreria WiFi al automatizar el proceso de mantener la conectividad siempre que sea posible. Se encargar\u00e1 de intentar la conexion a una red y mantenerla, y en caso de perderse, repetira el proceso con otra de las redes configuradas, hasta que recupere la conectividad. El programador s\u00f3lo tendr\u00e1 que definir las redes que conocer\u00e1 el dispositivo, con sus passwords en caso de necesitarse, y luego llamar al metodo .run() en el loop principal para mantener actualizado el estado de la libreria. Esto facilitar\u00e1 la tarea de utilizarlo en el taller, en casa, en el trabajo \u2026 con solo configurar una sola vez las posibles redes que tendr\u00e1 disponibles en alg\u00fan momento. En este caso no es una libreria instalable de forma individual, ya est\u00e1 instalada como parte del soporte para ESP8266, por lo que para su uso s\u00f3lo ser\u00e1 necesario incluir la cabecera. Libreria Enlaces de inter\u00e9s ESP8266WiFiMulti de Markus Sattler Repositorio (ESP8266WiFiMulti.h) Documentado en ejemplos Ejemplos C\u00f3digo fuente","title":"Resumen"},{"location":"arduino/practica-03/#ejemplo-funcional_4","text":"/* Include required headers and/or libraries */ #include <ESP8266WiFi.h> #include <ESP8266WiFiMulti.h> /* Instantiate a ESP8266WiFiMulti object called WiFiMulti */ ESP8266WiFiMulti WiFiMulti; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Comment the following line to disable debug output */ Serial.setDebugOutput(true); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Ensure to work as Station (disables internal AP) */ WiFi.mode(WIFI_STA); /* Add your home/personal wifi here */ WiFiMulti.addAP(\"personal-wifi\", \"the_password\"); /* If not found, will try to connect to this one */ WiFiMulti.addAP(\"IoTesla\", \"euroavia2019\"); } /* * Recurrent task, called forever */ void loop() { /* Pass the control to WifiMulti so it can check the network */ switch (WiFiMulti.run()) { /* 'WiFiMulti.run()' returns a status code. * The following switch..case shows all the valid cases for didactic * purposes, but tipically is only checked one or two cases, if so. */ case WL_IDLE_STATUS: Serial.printf(\"Returned WL_IDLE_STATUS\\n\"); break; case WL_NO_SSID_AVAIL: Serial.printf(\"Returned WL_NO_SSID_AVAIL\\n\"); break; case WL_SCAN_COMPLETED: Serial.printf(\"Returned WL_SCAN_COMPLETED\\n\"); break; case WL_CONNECTED: Serial.printf(\"Returned WL_CONNECTED\\n\"); break; case WL_CONNECT_FAILED: Serial.printf(\"Returned WL_CONNECT_FAILED\\n\"); break; case WL_CONNECTION_LOST: Serial.printf(\"Returned WL_CONNECTION_LOST\\n\"); break; case WL_DISCONNECTED: Serial.printf(\"Returned WL_DISCONNECTED\\n\"); break; } /* Ensure not to flood with a huge amount of fast data */ delay(500); }","title":"Ejemplo funcional"},{"location":"arduino/practica-03/#salida-esperada_4","text":"Ahoy! ESP8266 here! --- scandone Returned WL_DISCONNECTED Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL Returned WL_NO_SSID_AVAIL scandone scandone state: 0 -> 2 (b0) state: 2 -> 3 (0) state: 3 -> 5 (10) add 0 aid 3 cnt connected with IoTesla, channel 9 dhcp client start... ip:192.168.1.245,mask:255.255.255.0,gw:192.168.1.1 Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED Returned WL_CONNECTED","title":"Salida esperada"},{"location":"arduino/practica-04/","text":"Pr\u00e1ctica 4 TBD","title":"Pr\u00e1ctica 4"},{"location":"arduino/practica-04/#practica-4","text":"TBD","title":"Pr\u00e1ctica 4"},{"location":"hardware/","text":"Hardware Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente. Microcontrolador ESP8266 Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro: Wi-Fi Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip Hardware Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface - Software Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App Placa base: WeMos D1 Mini Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini D\u00f3nde comprar Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link Sensor BME280: Temperatura, humedad y presion Descargar hoja de datos completa BME280 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"Hardware"},{"location":"hardware/#hardware","text":"Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente.","title":"Hardware"},{"location":"hardware/#microcontrolador-esp8266","text":"Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro:","title":"Microcontrolador ESP8266"},{"location":"hardware/#wi-fi","text":"Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip","title":"Wi-Fi"},{"location":"hardware/#hardware_1","text":"Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface -","title":"Hardware"},{"location":"hardware/#software","text":"Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App","title":"Software"},{"location":"hardware/#placa-base-wemos-d1-mini","text":"Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini","title":"Placa base: WeMos D1 Mini"},{"location":"hardware/#donde-comprar","text":"Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-bme280-temperatura-humedad-y-presion","text":"Descargar hoja de datos completa BME280","title":"Sensor BME280: Temperatura, humedad y presion"},{"location":"hardware/#donde-comprar_1","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-mpu6050-giroscopo-de-3-ejes-y-acelerometro-de-3-ejes","text":"Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050","title":"Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes"},{"location":"hardware/#donde-comprar_2","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"D\u00f3nde comprar"},{"location":"introduccion/","text":"Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"introduccion/#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"introduccion/carpeta-de-trabajo/","text":"Carpeta de trabajo TBD","title":"Carpeta de trabajo"},{"location":"introduccion/carpeta-de-trabajo/#carpeta-de-trabajo","text":"TBD","title":"Carpeta de trabajo"},{"location":"lenguaje-c/","text":"Lenguaje C y C99 Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf Tutorial de C/C++ de tenouk.com Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"Lenguaje C y C99"},{"location":"lenguaje-c/#lenguaje-c-y-c99","text":"Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf","title":"Lenguaje C y C99"},{"location":"lenguaje-c/#tutorial-de-cc-de-tenoukcom","text":"Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"Tutorial de C/C++ de tenouk.com"},{"location":"lenguaje-c/punteros/","text":"Punteros Taller Ejemplo 1: Punteros simples En este ejemplo se usan de forma b\u00e1sica los punteros de C. Se ver\u00e1 como se crean y asignan, como se reasignan dir\u00e9ctamente o mediante aritm\u00e9tica simple. Este ejemplo mostrar\u00e1 una informaci\u00f3n y se bloquear\u00e1. Para poder volver a verla hay que resetear la placa pulsando brevemente el bot\u00f3n de reset lateral. /* Include required headers and/or libraries */ /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); } /* * Recurrent task, called forever */ void loop() { /* Create some variables of different types */ uint8_t var_u8 = 8; int8_t var_i8 = -8; char var_ch = 'c'; uint16_t var_u16 = 16; int16_t var_i16 = -16; uint32_t var_u32 = 32; int32_t var_i32 = -32; float var_flt = 1.0; double var_dbl = 2.0; /* Create a few arrays */ uint8_t arr_u8[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int8_t arr_i8[8] = { -1, -2, -3, -4, -5, -6, -7, -8 }; char arr_ch[8] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' }; /* Create a few simple (single) pointers */ uint8_t *pt_u8 = &var_u8; int8_t *pt_i8 = &var_i8; char *pt_ch = &var_ch; /* Check some variables assignments */ Serial.printf(\"Checking variables assignments:\\n\"); Serial.printf(\"(TIP: '@' means 'addressed at')\\n\"); Serial.printf(\" - Direct-access (using variable name):\\n\"); Serial.printf(\" - uint8_t var_u8 ...: %3u @ 0x%X\\n\", var_u8, &var_u8); Serial.printf(\" - int8_t var_i8 ...: %3i @ 0x%X\\n\", var_i8, &var_i8); Serial.printf(\" - char var_ch ...: %3c @ 0x%X\\n\", var_ch, &var_ch); Serial.printf(\" - uint16_t var_u16 ..: %3u @ 0x%X\\n\", var_u16, &var_u16); Serial.printf(\" - int16_t var_i16 ..: %3i @ 0x%X\\n\", var_i16, &var_i16); Serial.printf(\" - uint32_t var_u32 ..: %3u @ 0x%X\\n\", var_u32, &var_u32); Serial.printf(\" - int32_t var_i32 ..: %3i @ 0x%X\\n\", var_i32, &var_i32); Serial.printf(\" - float var_flt ..: %1.1f @ 0x%X\\n\", var_flt, &var_flt); Serial.printf(\" - double var_dbl ..: %1.1f @ 0x%X\\n\", var_dbl, &var_dbl); Serial.printf(\" - Indirect-access (using pointers):\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* Reassign pointers from single variables to arrays members */ /* Same: pt_u8 = &arr_u8[0]; */ pt_u8 = arr_u8; /* Same: pt_i8 = &arr_i8[0]; */ pt_i8 = arr_i8; /* Same: pt_ch = &arr_ch[0]; */ pt_ch = arr_ch; Serial.printf(\" - Same pointers, but reassigned to arrays:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* Move to next position on arrays */ pt_u8++; pt_i8++; pt_ch++; Serial.printf(\" - Same pointers, but after incrementing by 1:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* ~~ o ~~ */ /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } } Salida esperada Ahoy! ESP8266 here! --- Checking variables assignments: (TIP: '@' means 'addressed at') - Direct-access (using variable name): - uint8_t var_u8 ...: 8 @ 0x3FFFFF82 - int8_t var_i8 ...: -8 @ 0x3FFFFF81 - char var_ch ...: c @ 0x3FFFFF80 - uint16_t var_u16 ..: 16 @ 0x3FFFFF7E - int16_t var_i16 ..: -16 @ 0x3FFFFF7C - uint32_t var_u32 ..: 32 @ 0x3FFFFF78 - int32_t var_i32 ..: -32 @ 0x3FFFFF74 - float var_flt ..: 1.0 @ 0x3FFFFF70 - double var_dbl ..: 2.0 @ 0x3FFFFF68 - Indirect-access (using pointers): - Pointed by pt_u8 ..: 8 @ 0x3FFFFF82 - Pointed by pt_i8 ..: -8 @ 0x3FFFFF81 - Pointed by pt_ch ..: c @ 0x3FFFFF80 - Same pointers, but reassigned to arrays: - Pointed by pt_u8 ..: 1 @ 0x3FFFFF60 - Pointed by pt_i8 ..: -1 @ 0x3FFFFF58 - Pointed by pt_ch ..: a @ 0x3FFFFF50 - Same pointers, but after incrementing by 1: - Pointed by pt_u8 ..: 2 @ 0x3FFFFF61 - Pointed by pt_i8 ..: -2 @ 0x3FFFFF59 - Pointed by pt_ch ..: b @ 0x3FFFFF51 Locking now Ejemplo 2: Mezclando signos y tipos En este ejemplo se muestran todas las direcciones en forma de tabla y se accede a unos elementos interpretandolos de forma diferente al tipo que los define, a traves de su direcci\u00f3n (usando punteros). Este ejemplo mostrar\u00e1 una informaci\u00f3n y se bloquear\u00e1. Para poder volver a verla hay que resetear la placa pulsando brevemente el bot\u00f3n de reset lateral. /* Include required headers and/or libraries */ /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); } /* * Recurrent task, called forever */ void loop() { /* Create a few arrays */ uint8_t arr_u8[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int8_t arr_i8[8] = { -1, -2, -3, -4, -5, -6, -7, -8 }; char arr_ch[8] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' }; /* * Print a table of addresses */ /* Helper variables */ uint8_t idx0 = 0; Serial.printf(\"Address of each array member:\\n\"); Serial.printf(\"\\n\"); /* Table: Header */ Serial.printf(\" Type \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| Index nr.%u \", idx0); } Serial.printf(\"\\n\"); /* Table: Separator */ Serial.printf(\"---------\"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"+------------\"); } Serial.printf(\"\\n\"); /* Table: uint8_t row */ Serial.printf(\" uint8_t \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_u8[idx0]); } Serial.printf(\"\\n\"); /* Table: int8_t row */ Serial.printf(\" int8_t \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_i8[idx0]); } Serial.printf(\"\\n\"); /* Table: char row */ Serial.printf(\" char \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_ch[idx0]); } Serial.printf(\"\\n\"); /* Create a few simple (single) pointers */ uint8_t *pt_u8 = &arr_u8[7]; int8_t *pt_i8 = &arr_i8[7]; char *pt_ch = &arr_ch[7]; uint32_t *pt_u32 = NULL; /* Check some variables assignments */ Serial.printf(\"\\n\"); Serial.printf(\"Checking variables assignments:\\n\"); Serial.printf(\" - Indirect-access (using pointers):\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %8u [0x%08X]\\n\", *pt_u8, *pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %8i [0x%08X]\\n\", *pt_i8, *pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %8c [0x%08X]\\n\", *pt_ch, *pt_ch); /* What if we re-read an address thinking it has a different sign? */ pt_u8 = (uint8_t *)pt_i8; Serial.printf(\" - A uint8_t reading data from a negative int8_t:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %8u [0x%08X]\\n\", *pt_u8, *pt_u8); /* What if we re-read it again, but thinking on different size? */ pt_u32 = (uint32_t *)pt_i8; Serial.printf(\" - A uint32_t reading data from a negative int8_t:\\n\"); Serial.printf(\" - Pointed by pt_u32 .: %8u [0x%08X]\\n\", *pt_u32, *pt_u32); /* ~~ o ~~ */ /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } } Salida esperada Ahoy! ESP8266 here! --- Address of each array member: Type | Index nr.0 | Index nr.1 | Index nr.2 | Index nr.3 | Index nr.4 | Index nr.5 | Index nr.6 | Index nr.7 ---------+------------+------------+------------+------------+------------+------------+------------+------------ uint8_t | 0x3FFFFF70 | 0x3FFFFF71 | 0x3FFFFF72 | 0x3FFFFF73 | 0x3FFFFF74 | 0x3FFFFF75 | 0x3FFFFF76 | 0x3FFFFF77 int8_t | 0x3FFFFF68 | 0x3FFFFF69 | 0x3FFFFF6A | 0x3FFFFF6B | 0x3FFFFF6C | 0x3FFFFF6D | 0x3FFFFF6E | 0x3FFFFF6F char | 0x3FFFFF60 | 0x3FFFFF61 | 0x3FFFFF62 | 0x3FFFFF63 | 0x3FFFFF64 | 0x3FFFFF65 | 0x3FFFFF66 | 0x3FFFFF67 Checking variables assignments: - Indirect-access (using pointers): - Pointed by pt_u8 ..: 8 [0x00000008] - Pointed by pt_i8 ..: -8 [0xFFFFFFF8] - Pointed by pt_ch ..: h [0x00000068] - A uint8_t reading data from a negative int8_t: - Pointed by pt_u8 ..: 248 [0x000000F8] - A uint32_t reading data from a negative int8_t: - Pointed by pt_u32 .: 50463224 [0x030201F8] Locking now","title":"Punteros"},{"location":"lenguaje-c/punteros/#punteros","text":"","title":"Punteros"},{"location":"lenguaje-c/punteros/#taller","text":"","title":"Taller"},{"location":"lenguaje-c/punteros/#ejemplo-1-punteros-simples","text":"En este ejemplo se usan de forma b\u00e1sica los punteros de C. Se ver\u00e1 como se crean y asignan, como se reasignan dir\u00e9ctamente o mediante aritm\u00e9tica simple. Este ejemplo mostrar\u00e1 una informaci\u00f3n y se bloquear\u00e1. Para poder volver a verla hay que resetear la placa pulsando brevemente el bot\u00f3n de reset lateral. /* Include required headers and/or libraries */ /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); } /* * Recurrent task, called forever */ void loop() { /* Create some variables of different types */ uint8_t var_u8 = 8; int8_t var_i8 = -8; char var_ch = 'c'; uint16_t var_u16 = 16; int16_t var_i16 = -16; uint32_t var_u32 = 32; int32_t var_i32 = -32; float var_flt = 1.0; double var_dbl = 2.0; /* Create a few arrays */ uint8_t arr_u8[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int8_t arr_i8[8] = { -1, -2, -3, -4, -5, -6, -7, -8 }; char arr_ch[8] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' }; /* Create a few simple (single) pointers */ uint8_t *pt_u8 = &var_u8; int8_t *pt_i8 = &var_i8; char *pt_ch = &var_ch; /* Check some variables assignments */ Serial.printf(\"Checking variables assignments:\\n\"); Serial.printf(\"(TIP: '@' means 'addressed at')\\n\"); Serial.printf(\" - Direct-access (using variable name):\\n\"); Serial.printf(\" - uint8_t var_u8 ...: %3u @ 0x%X\\n\", var_u8, &var_u8); Serial.printf(\" - int8_t var_i8 ...: %3i @ 0x%X\\n\", var_i8, &var_i8); Serial.printf(\" - char var_ch ...: %3c @ 0x%X\\n\", var_ch, &var_ch); Serial.printf(\" - uint16_t var_u16 ..: %3u @ 0x%X\\n\", var_u16, &var_u16); Serial.printf(\" - int16_t var_i16 ..: %3i @ 0x%X\\n\", var_i16, &var_i16); Serial.printf(\" - uint32_t var_u32 ..: %3u @ 0x%X\\n\", var_u32, &var_u32); Serial.printf(\" - int32_t var_i32 ..: %3i @ 0x%X\\n\", var_i32, &var_i32); Serial.printf(\" - float var_flt ..: %1.1f @ 0x%X\\n\", var_flt, &var_flt); Serial.printf(\" - double var_dbl ..: %1.1f @ 0x%X\\n\", var_dbl, &var_dbl); Serial.printf(\" - Indirect-access (using pointers):\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* Reassign pointers from single variables to arrays members */ /* Same: pt_u8 = &arr_u8[0]; */ pt_u8 = arr_u8; /* Same: pt_i8 = &arr_i8[0]; */ pt_i8 = arr_i8; /* Same: pt_ch = &arr_ch[0]; */ pt_ch = arr_ch; Serial.printf(\" - Same pointers, but reassigned to arrays:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* Move to next position on arrays */ pt_u8++; pt_i8++; pt_ch++; Serial.printf(\" - Same pointers, but after incrementing by 1:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %3u @ 0x%X\\n\", *pt_u8, pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %3i @ 0x%X\\n\", *pt_i8, pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %3c @ 0x%X\\n\", *pt_ch, pt_ch); /* ~~ o ~~ */ /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } }","title":"Ejemplo 1: Punteros simples"},{"location":"lenguaje-c/punteros/#salida-esperada","text":"Ahoy! ESP8266 here! --- Checking variables assignments: (TIP: '@' means 'addressed at') - Direct-access (using variable name): - uint8_t var_u8 ...: 8 @ 0x3FFFFF82 - int8_t var_i8 ...: -8 @ 0x3FFFFF81 - char var_ch ...: c @ 0x3FFFFF80 - uint16_t var_u16 ..: 16 @ 0x3FFFFF7E - int16_t var_i16 ..: -16 @ 0x3FFFFF7C - uint32_t var_u32 ..: 32 @ 0x3FFFFF78 - int32_t var_i32 ..: -32 @ 0x3FFFFF74 - float var_flt ..: 1.0 @ 0x3FFFFF70 - double var_dbl ..: 2.0 @ 0x3FFFFF68 - Indirect-access (using pointers): - Pointed by pt_u8 ..: 8 @ 0x3FFFFF82 - Pointed by pt_i8 ..: -8 @ 0x3FFFFF81 - Pointed by pt_ch ..: c @ 0x3FFFFF80 - Same pointers, but reassigned to arrays: - Pointed by pt_u8 ..: 1 @ 0x3FFFFF60 - Pointed by pt_i8 ..: -1 @ 0x3FFFFF58 - Pointed by pt_ch ..: a @ 0x3FFFFF50 - Same pointers, but after incrementing by 1: - Pointed by pt_u8 ..: 2 @ 0x3FFFFF61 - Pointed by pt_i8 ..: -2 @ 0x3FFFFF59 - Pointed by pt_ch ..: b @ 0x3FFFFF51 Locking now","title":"Salida esperada"},{"location":"lenguaje-c/punteros/#ejemplo-2-mezclando-signos-y-tipos","text":"En este ejemplo se muestran todas las direcciones en forma de tabla y se accede a unos elementos interpretandolos de forma diferente al tipo que los define, a traves de su direcci\u00f3n (usando punteros). Este ejemplo mostrar\u00e1 una informaci\u00f3n y se bloquear\u00e1. Para poder volver a verla hay que resetear la placa pulsando brevemente el bot\u00f3n de reset lateral. /* Include required headers and/or libraries */ /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); } /* * Recurrent task, called forever */ void loop() { /* Create a few arrays */ uint8_t arr_u8[8] = { 1, 2, 3, 4, 5, 6, 7, 8 }; int8_t arr_i8[8] = { -1, -2, -3, -4, -5, -6, -7, -8 }; char arr_ch[8] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h' }; /* * Print a table of addresses */ /* Helper variables */ uint8_t idx0 = 0; Serial.printf(\"Address of each array member:\\n\"); Serial.printf(\"\\n\"); /* Table: Header */ Serial.printf(\" Type \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| Index nr.%u \", idx0); } Serial.printf(\"\\n\"); /* Table: Separator */ Serial.printf(\"---------\"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"+------------\"); } Serial.printf(\"\\n\"); /* Table: uint8_t row */ Serial.printf(\" uint8_t \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_u8[idx0]); } Serial.printf(\"\\n\"); /* Table: int8_t row */ Serial.printf(\" int8_t \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_i8[idx0]); } Serial.printf(\"\\n\"); /* Table: char row */ Serial.printf(\" char \"); for (idx0 = 0; idx0 < 8; idx0++) { Serial.printf(\"| 0x%08X \", &arr_ch[idx0]); } Serial.printf(\"\\n\"); /* Create a few simple (single) pointers */ uint8_t *pt_u8 = &arr_u8[7]; int8_t *pt_i8 = &arr_i8[7]; char *pt_ch = &arr_ch[7]; uint32_t *pt_u32 = NULL; /* Check some variables assignments */ Serial.printf(\"\\n\"); Serial.printf(\"Checking variables assignments:\\n\"); Serial.printf(\" - Indirect-access (using pointers):\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %8u [0x%08X]\\n\", *pt_u8, *pt_u8); Serial.printf(\" - Pointed by pt_i8 ..: %8i [0x%08X]\\n\", *pt_i8, *pt_i8); Serial.printf(\" - Pointed by pt_ch ..: %8c [0x%08X]\\n\", *pt_ch, *pt_ch); /* What if we re-read an address thinking it has a different sign? */ pt_u8 = (uint8_t *)pt_i8; Serial.printf(\" - A uint8_t reading data from a negative int8_t:\\n\"); Serial.printf(\" - Pointed by pt_u8 ..: %8u [0x%08X]\\n\", *pt_u8, *pt_u8); /* What if we re-read it again, but thinking on different size? */ pt_u32 = (uint32_t *)pt_i8; Serial.printf(\" - A uint32_t reading data from a negative int8_t:\\n\"); Serial.printf(\" - Pointed by pt_u32 .: %8u [0x%08X]\\n\", *pt_u32, *pt_u32); /* ~~ o ~~ */ /* Process is locked until reset is performed */ Serial.printf(\"Locking now\\n\"); while (true) { /* Ensure other tasks are working (avoid WDT reset) */ yield(); } }","title":"Ejemplo 2: Mezclando signos y tipos"},{"location":"lenguaje-c/punteros/#salida-esperada_1","text":"Ahoy! ESP8266 here! --- Address of each array member: Type | Index nr.0 | Index nr.1 | Index nr.2 | Index nr.3 | Index nr.4 | Index nr.5 | Index nr.6 | Index nr.7 ---------+------------+------------+------------+------------+------------+------------+------------+------------ uint8_t | 0x3FFFFF70 | 0x3FFFFF71 | 0x3FFFFF72 | 0x3FFFFF73 | 0x3FFFFF74 | 0x3FFFFF75 | 0x3FFFFF76 | 0x3FFFFF77 int8_t | 0x3FFFFF68 | 0x3FFFFF69 | 0x3FFFFF6A | 0x3FFFFF6B | 0x3FFFFF6C | 0x3FFFFF6D | 0x3FFFFF6E | 0x3FFFFF6F char | 0x3FFFFF60 | 0x3FFFFF61 | 0x3FFFFF62 | 0x3FFFFF63 | 0x3FFFFF64 | 0x3FFFFF65 | 0x3FFFFF66 | 0x3FFFFF67 Checking variables assignments: - Indirect-access (using pointers): - Pointed by pt_u8 ..: 8 [0x00000008] - Pointed by pt_i8 ..: -8 [0xFFFFFFF8] - Pointed by pt_ch ..: h [0x00000068] - A uint8_t reading data from a negative int8_t: - Pointed by pt_u8 ..: 248 [0x000000F8] - A uint32_t reading data from a negative int8_t: - Pointed by pt_u32 .: 50463224 [0x030201F8] Locking now","title":"Salida esperada"},{"location":"otros-recursos/","text":"Otros recursos Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje. Servidor de apoyo Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Otros recursos"},{"location":"otros-recursos/#otros-recursos","text":"Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje.","title":"Otros recursos"},{"location":"otros-recursos/#servidor-de-apoyo","text":"Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Servidor de apoyo"},{"location":"otros-recursos/mqtt-broker/","text":"MQTT Broker A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone) Install both broker and clients root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker. Configure protocols Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure storage and persistence This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure password file and users Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE Configure access control list (ACL) Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/# Configure clients access Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#mqtt-broker","text":"A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone)","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#install-both-broker-and-clients","text":"root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker.","title":"Install both broker and clients"},{"location":"otros-recursos/mqtt-broker/#configure-protocols","text":"Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure protocols"},{"location":"otros-recursos/mqtt-broker/#configure-storage-and-persistence","text":"This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure storage and persistence"},{"location":"otros-recursos/mqtt-broker/#configure-password-file-and-users","text":"Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE","title":"Configure password file and users"},{"location":"otros-recursos/mqtt-broker/#configure-access-control-list-acl","text":"Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/#","title":"Configure access control list (ACL)"},{"location":"otros-recursos/mqtt-broker/#configure-clients-access","text":"Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure clients access"}]}