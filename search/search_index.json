{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de C y Arduino para Euroavia Sevilla Se dividir\u00e1 en las siguientes secciones: Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados Lenguaje C Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino Hardware Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller Arduino Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Home"},{"location":"#taller-de-c-y-arduino-para-euroavia-sevilla","text":"Se dividir\u00e1 en las siguientes secciones:","title":" Taller de C y Arduino para Euroavia Sevilla"},{"location":"#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"#lenguaje-c","text":"Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino","title":"Lenguaje C"},{"location":"#hardware","text":"Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller","title":"Hardware"},{"location":"#arduino","text":"Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Arduino"},{"location":"arduino/","text":"Introducci\u00f3n a Arduino TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/#introduccion-a-arduino","text":"TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/practica-01/","text":"Pr\u00e1ctica 1 TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-01/#practica-1","text":"TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-02/","text":"Pr\u00e1ctica 2 - El bus I2C Introducci\u00f3n Antes de comenzar, se debe entender el concepto de bus: En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. Wikipedia El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir dicha comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentaci\u00f3n, Vcc y GND, y dos espec\u00edficas, SCL (linea de reloj) y SDA (linea de datos). Esto mismo se representa en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No ser\u00e1 necesaria su lectura para la pr\u00e1ctica, pero no est\u00e1 de mas tener a mano la documentaci\u00f3n de cada parte para casos de duda, aprendizaje o pura curiosidad. Descargar I2C-bus specification and user manual (UM10204) Como continuar Lo siguiente ser\u00e1 informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraer\u00e1 todo el bajo nivel a modo de funciones incluidas mediante librer\u00edas. El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino. Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso. Dichas librerias pueden ser parte del conjunto est\u00e1ndar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librer\u00eda que da soporte Arduino al chip ESP8266 (de otro modo, no ser\u00eda posible trabajar con el entorno de Arduino y la placa proporcionada). Para poder usarlas es necesario leer su documentacion de antemano, que se compone de: Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Librerias de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. https://www.arduino.cc/en/Reference/Libraries Como se indica, se recomienda primero ver la parte espec\u00edfica y luego la general, ya que tendr\u00e1 preferencia en el momento de su uso. Esto pasa con la funcion Wire.begin() : Wire.begin() existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusi\u00f3n aunque el programa sea totalmente correcto. Lo correcto ser\u00e1 usar Wire.begin() como dicta la libreria del ESP8266: Wire.begin(SDA_pin, SCL_pin) . Esto arrancar\u00e1 el perif\u00e9rico I2C en modo maestro usando concr\u00e9tamente esos pines. Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usar\u00e1n como dicta la libreria Wire de Arduino. Pr\u00e1ctica En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con el dispositivo BME280 acoplado al D1 Mini. Para referencia, el montaje proporcionado equivale al siguiente esquem\u00e1tico: Primera comunicaci\u00f3n I2C Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* Start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no se llevar\u00e1 a cabo una comunicaci\u00f3n v\u00e1lida por no existir un esclavo con la direcci\u00f3n 0x12 , lo que deja la duda de .. entonces cual es la correcta? . Para responderla es necesario estudiar los dispositivos , documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante. Leer un byte En el caso del BME280, tras leer su datasheet , vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , seg\u00fan si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder. Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no est\u00e9n sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la funci\u00f3n Wire.available() . Incluyendo ambos cambios, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_available-byte.ino en GitHub El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- Received byte: 0x03 Ahoy! ESP8266 here! --- Received byte: 0x1E Ahoy! ESP8266 here! --- Received byte: 0x27 Ahoy! ESP8266 here! --- Received byte: 0x41 Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicar\u00e1 que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa autom\u00e1ticamente con cada lectura, y se reinicia llegado a un tope. Leer de una direcci\u00f3n concreta Si nos fijamos bien, en el ejemplo anterior no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato de una direcci\u00f3n concreta es necesario direccionarlo primero. De nuevo su datasheet detalla c\u00f3mo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas. Interpret\u00e1ndola, ser\u00e1 necesario: Hacer una escritura, en la que el dato enviado ser\u00e1 la direcci\u00f3n de la que queremos leer El BME280 internamente reposicionar\u00e1 su puntero de memoria. Entonces se procede a la lectura Ahora es cuando el BME280 devolver\u00e1 los datos almacenados a partir de la direcci\u00f3n pedida Si en lugar de varios queremos un \u00fanico byte, simplemente tendremos que pedir un \u00fanico byte . Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID , localizado en la direcci\u00f3n 0xD0 . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n Si todo esto se traduce a c\u00f3digo, lo visto quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(0x76); Wire.write(0xD0); Wire.endTransmission(); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_byte-addressing.ino en GitHub El programa deber\u00eda imprimir por puerto serie ex\u00e1ctamente lo siguiente: Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Que indicar\u00e1 que se ha le\u00eddo correctamente el identificador de chip, localizado en la direcci\u00f3n 0xD0 , con el valor esperado de 0x60 . Leer un bloque de memoria Siguiendo la misma linea del ejemplo anterior, lo l\u00f3gico ser\u00eda pensar en hacer varios Wire.read() y salvar el resultado, algo como: (...) /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 3); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c0 = Wire.read(); uint8_t c1 = Wire.read(); uint8_t c2 = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received bytes: 0x%02X, 0x%02X and 0x%02X\\n\", c0, c1, c2); } (...) Pero resulta un m\u00e9todo tedioso y muy poco eficiente, en el que un bloque simple de 128 bytes ser\u00eda un programa enorme para una tarea muy sencilla. En este momento entran en juego los arrays , que son matrices compuestas por un numero finito de elementos de alg\u00fan tipo definido. Para este caso se deber\u00e1 usar un array de elementos de tipo uint8_t . Junto al array, se utilizar\u00e1 una variable secundaria que servir\u00e1 de \u00edndice para almacenar la posici\u00f3n dentro del array donde se salvar\u00e1 el siguiente dato. Esta variable comenzar\u00e1 siendo 0 y se incrementar\u00e1 cada vez que se reciba un dato. Ahora queda saber desde qu\u00e9 direcci\u00f3n comenzar a leer, y para esto el datasheet proporciona el mapa de registros en memoria y sus direcciones, como se ve en la siguiente figura: Como se puede observar, el primer dato se encuentra en la direcci\u00f3n 0x88 y el \u00faltimo en la 0xFE , sumando un total de 118 bytes. Arduino tiene un limite interno para Wire.requestFrom() de 128 bytes , y como se necesitan s\u00f3lo 118 no deber\u00eda haber problema, pero hay que tenerlo en cuenta en caso de necesitarse transferencias de mayor tama\u00f1o, ya que habr\u00eda que fraccionarlas. Llevado a c\u00f3digo, el nuevo programa podr\u00eda quedar como sigue: /* Include required headers and/or libraries */ #include <Wire.h> #define SLAVE_ADDRESS 0x76 #define BLOCK_ADDRESS 0x88 #define BLOCK_LENGTH 118 /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(SLAVE_ADDRESS); Wire.write(BLOCK_ADDRESS); Wire.endTransmission(); /* Use static to prevent block re-allocation on each pass */ static uint8_t memory_map[BLOCK_LENGTH] = { 0x00 }; /* Array index, stores position to write a received byte */ uint8_t memory_idx = 0; /* Used to check the received amount */ uint8_t rx_bytes = 0; /* Request data from slave */ Wire.requestFrom(SLAVE_ADDRESS, BLOCK_LENGTH); /* Wait for data to be available */ while (rx_bytes == 0) { rx_bytes = Wire.available(); } /* Save the block */ for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { memory_map[memory_idx] = Wire.read(); } /* Print the block */ Serial.printf(\" ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n\"); Serial.printf(\"----+------------------------------------------------\"); for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { /* Create a new line each 16 printed bytes */ if ((memory_idx % 16) == 0) { Serial.printf(\"\\n %02X |\", memory_idx + BLOCK_ADDRESS); } /* Print a byte */ Serial.printf(\" %02X\", memory_map[memory_idx]); } Serial.printf(\"\\nEnd of data\\n\"); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_block-read.ino en GitHub En este ejemplo se ha incluido el uso de macros de precompilacion, como por ejemplo pasa con #define BLOCK_LENGTH 118 . Esto crea BLOCK_LENGTH , que parece y funciona como una variable ya que se sustituye por el numero 118, pero que se sustituye antes de compilar el programa, por lo que es como si se escribiera el numero 118 en el propio c\u00f3digo. Macro frente a Variable: La diferencia es que al tratarse de un valor constante, pues 118 no cambiar\u00e1 nunca a lo largo del programa, usar una variable para esto es un malgasto de memoria RAM. Macro frente a N\u00famero: La diferencia es que el uso de un nombre descriptivo frente a un simple numero siempre ser\u00e1 mas claro de leer y de entender. El uso de n\u00fameros sin descripci\u00f3n es una mala pr\u00e1ctica, y debe evitarse siempre que sea posible. Se conoce tambien como \u2018hardcoding\u2019 o \u2018magic numbers\u2019: In computer programming, the term magic number has multiple meanings. It could refer to one or more of the following: Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants A constant numerical or text value used to identify a file format or protocol; for files, see List of file signatures Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., Globally Unique Identifiers) Wikipedia El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Como puede comprobarse, el Chip ID puede leerse como 60 en la posici\u00f3n con fila C8 y columna 08 (que se corresponde a 0xC8 + 0x08 = 0xD0 , la direcci\u00f3n del Chip ID).","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#practica-2-el-bus-i2c","text":"","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#introduccion","text":"Antes de comenzar, se debe entender el concepto de bus: En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. Wikipedia El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir dicha comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentaci\u00f3n, Vcc y GND, y dos espec\u00edficas, SCL (linea de reloj) y SDA (linea de datos). Esto mismo se representa en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No ser\u00e1 necesaria su lectura para la pr\u00e1ctica, pero no est\u00e1 de mas tener a mano la documentaci\u00f3n de cada parte para casos de duda, aprendizaje o pura curiosidad. Descargar I2C-bus specification and user manual (UM10204)","title":"Introducci\u00f3n"},{"location":"arduino/practica-02/#como-continuar","text":"Lo siguiente ser\u00e1 informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraer\u00e1 todo el bajo nivel a modo de funciones incluidas mediante librer\u00edas. El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino. Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso. Dichas librerias pueden ser parte del conjunto est\u00e1ndar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librer\u00eda que da soporte Arduino al chip ESP8266 (de otro modo, no ser\u00eda posible trabajar con el entorno de Arduino y la placa proporcionada). Para poder usarlas es necesario leer su documentacion de antemano, que se compone de: Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Librerias de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. https://www.arduino.cc/en/Reference/Libraries Como se indica, se recomienda primero ver la parte espec\u00edfica y luego la general, ya que tendr\u00e1 preferencia en el momento de su uso. Esto pasa con la funcion Wire.begin() : Wire.begin() existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusi\u00f3n aunque el programa sea totalmente correcto. Lo correcto ser\u00e1 usar Wire.begin() como dicta la libreria del ESP8266: Wire.begin(SDA_pin, SCL_pin) . Esto arrancar\u00e1 el perif\u00e9rico I2C en modo maestro usando concr\u00e9tamente esos pines. Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usar\u00e1n como dicta la libreria Wire de Arduino.","title":"Como continuar"},{"location":"arduino/practica-02/#practica","text":"En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con el dispositivo BME280 acoplado al D1 Mini. Para referencia, el montaje proporcionado equivale al siguiente esquem\u00e1tico:","title":"Pr\u00e1ctica"},{"location":"arduino/practica-02/#primera-comunicacion-i2c","text":"Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* Start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no se llevar\u00e1 a cabo una comunicaci\u00f3n v\u00e1lida por no existir un esclavo con la direcci\u00f3n 0x12 , lo que deja la duda de .. entonces cual es la correcta? . Para responderla es necesario estudiar los dispositivos , documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante.","title":"Primera comunicaci\u00f3n I2C"},{"location":"arduino/practica-02/#leer-un-byte","text":"En el caso del BME280, tras leer su datasheet , vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , seg\u00fan si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder. Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no est\u00e9n sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la funci\u00f3n Wire.available() . Incluyendo ambos cambios, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_available-byte.ino en GitHub El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- Received byte: 0x03 Ahoy! ESP8266 here! --- Received byte: 0x1E Ahoy! ESP8266 here! --- Received byte: 0x27 Ahoy! ESP8266 here! --- Received byte: 0x41 Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicar\u00e1 que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa autom\u00e1ticamente con cada lectura, y se reinicia llegado a un tope.","title":"Leer un byte"},{"location":"arduino/practica-02/#leer-de-una-direccion-concreta","text":"Si nos fijamos bien, en el ejemplo anterior no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato de una direcci\u00f3n concreta es necesario direccionarlo primero. De nuevo su datasheet detalla c\u00f3mo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas. Interpret\u00e1ndola, ser\u00e1 necesario: Hacer una escritura, en la que el dato enviado ser\u00e1 la direcci\u00f3n de la que queremos leer El BME280 internamente reposicionar\u00e1 su puntero de memoria. Entonces se procede a la lectura Ahora es cuando el BME280 devolver\u00e1 los datos almacenados a partir de la direcci\u00f3n pedida Si en lugar de varios queremos un \u00fanico byte, simplemente tendremos que pedir un \u00fanico byte . Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID , localizado en la direcci\u00f3n 0xD0 . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n Si todo esto se traduce a c\u00f3digo, lo visto quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(0x76); Wire.write(0xD0); Wire.endTransmission(); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: 0x%02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_byte-addressing.ino en GitHub El programa deber\u00eda imprimir por puerto serie ex\u00e1ctamente lo siguiente: Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Ahoy! ESP8266 here! --- Received byte: 0x60 Que indicar\u00e1 que se ha le\u00eddo correctamente el identificador de chip, localizado en la direcci\u00f3n 0xD0 , con el valor esperado de 0x60 .","title":"Leer de una direcci\u00f3n concreta"},{"location":"arduino/practica-02/#leer-un-bloque-de-memoria","text":"Siguiendo la misma linea del ejemplo anterior, lo l\u00f3gico ser\u00eda pensar en hacer varios Wire.read() y salvar el resultado, algo como: (...) /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 3); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c0 = Wire.read(); uint8_t c1 = Wire.read(); uint8_t c2 = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received bytes: 0x%02X, 0x%02X and 0x%02X\\n\", c0, c1, c2); } (...) Pero resulta un m\u00e9todo tedioso y muy poco eficiente, en el que un bloque simple de 128 bytes ser\u00eda un programa enorme para una tarea muy sencilla. En este momento entran en juego los arrays , que son matrices compuestas por un numero finito de elementos de alg\u00fan tipo definido. Para este caso se deber\u00e1 usar un array de elementos de tipo uint8_t . Junto al array, se utilizar\u00e1 una variable secundaria que servir\u00e1 de \u00edndice para almacenar la posici\u00f3n dentro del array donde se salvar\u00e1 el siguiente dato. Esta variable comenzar\u00e1 siendo 0 y se incrementar\u00e1 cada vez que se reciba un dato. Ahora queda saber desde qu\u00e9 direcci\u00f3n comenzar a leer, y para esto el datasheet proporciona el mapa de registros en memoria y sus direcciones, como se ve en la siguiente figura: Como se puede observar, el primer dato se encuentra en la direcci\u00f3n 0x88 y el \u00faltimo en la 0xFE , sumando un total de 118 bytes. Arduino tiene un limite interno para Wire.requestFrom() de 128 bytes , y como se necesitan s\u00f3lo 118 no deber\u00eda haber problema, pero hay que tenerlo en cuenta en caso de necesitarse transferencias de mayor tama\u00f1o, ya que habr\u00eda que fraccionarlas. Llevado a c\u00f3digo, el nuevo programa podr\u00eda quedar como sigue: /* Include required headers and/or libraries */ #include <Wire.h> #define SLAVE_ADDRESS 0x76 #define BLOCK_ADDRESS 0x88 #define BLOCK_LENGTH 118 /* * Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Tell the BME280 where we want to read */ Wire.beginTransmission(SLAVE_ADDRESS); Wire.write(BLOCK_ADDRESS); Wire.endTransmission(); /* Use static to prevent block re-allocation on each pass */ static uint8_t memory_map[BLOCK_LENGTH] = { 0x00 }; /* Array index, stores position to write a received byte */ uint8_t memory_idx = 0; /* Used to check the received amount */ uint8_t rx_bytes = 0; /* Request data from slave */ Wire.requestFrom(SLAVE_ADDRESS, BLOCK_LENGTH); /* Wait for data to be available */ while (rx_bytes == 0) { rx_bytes = Wire.available(); } /* Save the block */ for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { memory_map[memory_idx] = Wire.read(); } /* Print the block */ Serial.printf(\" ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\n\"); Serial.printf(\"----+------------------------------------------------\"); for (memory_idx = 0; memory_idx < rx_bytes; memory_idx++) { /* Create a new line each 16 printed bytes */ if ((memory_idx % 16) == 0) { Serial.printf(\"\\n %02X |\", memory_idx + BLOCK_ADDRESS); } /* Print a byte */ Serial.printf(\" %02X\", memory_map[memory_idx]); } Serial.printf(\"\\nEnd of data\\n\"); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Ver sketch BME280_block-read.ino en GitHub En este ejemplo se ha incluido el uso de macros de precompilacion, como por ejemplo pasa con #define BLOCK_LENGTH 118 . Esto crea BLOCK_LENGTH , que parece y funciona como una variable ya que se sustituye por el numero 118, pero que se sustituye antes de compilar el programa, por lo que es como si se escribiera el numero 118 en el propio c\u00f3digo. Macro frente a Variable: La diferencia es que al tratarse de un valor constante, pues 118 no cambiar\u00e1 nunca a lo largo del programa, usar una variable para esto es un malgasto de memoria RAM. Macro frente a N\u00famero: La diferencia es que el uso de un nombre descriptivo frente a un simple numero siempre ser\u00e1 mas claro de leer y de entender. El uso de n\u00fameros sin descripci\u00f3n es una mala pr\u00e1ctica, y debe evitarse siempre que sea posible. Se conoce tambien como \u2018hardcoding\u2019 o \u2018magic numbers\u2019: In computer programming, the term magic number has multiple meanings. It could refer to one or more of the following: Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants A constant numerical or text value used to identify a file format or protocol; for files, see List of file signatures Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., Globally Unique Identifiers) Wikipedia El programa deber\u00eda imprimir por puerto serie algo parecido a: Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Ahoy! ESP8266 here! --- ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F ----+------------------------------------------------ 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80 F8 | 00 00 80 00 00 80 End of data Como puede comprobarse, el Chip ID puede leerse como 60 en la posici\u00f3n con fila C8 y columna 08 (que se corresponde a 0xC8 + 0x08 = 0xD0 , la direcci\u00f3n del Chip ID).","title":"Leer un bloque de memoria"},{"location":"arduino/practica-03/","text":"Pr\u00e1ctica 3 - Uso de librer\u00edas Tras aprender lo que es el bus I2C y como acceder a los datos en bruto de un dispositivo, en esta pr\u00e1ctica se usar\u00e1 una libreria para que haga ese mismo trabajo. Esto supone una primera ventaja clara: en lugar de necesitar saber los pormenores de un chip, ahora solo ser\u00e1 necesario saber c\u00f3mo se usan las funciones de una librer\u00eda. Introducci\u00f3n Una libreria es uno o varios ficheros de c\u00f3digo en donde ya hay programadas ciertas funcionalidades y se incluyen en el c\u00f3digo en forma de paquete, lo que: Simplificar\u00e1 enormemente el proceso de desarrollo Incrementar\u00e1 la calidad y legibilidad del c\u00f3digo final Necesitar\u00e1 de mucho menos tiempo para obtener los mismos resultados Evitar\u00e1 errores innecesarios, pues normalmente han pasado muchas pruebas Si una libreria falla suele haber alternativas Aunque no se haya estudiado en profundidad, esto ya se ha utilizado en los programas del taller en el momento que se usa, por ejemplo, #include <Wire.h> . Lo que realmente se est\u00e1 haciendo es incluir la cabecera de la librer\u00eda Wire , que dar\u00e1 a conocer al programa una serie de variables, funciones, clases, etc. De esta forma pasan a estar disponibles, y por lo tanto, su funcionalidad. Dicho de otro modo, la librer\u00eda Wire evita tener que leer uno o varios datasheets de un microcontrolador para saber c\u00f3mo hacer funcionar el bus I2C en su forma mas basica. Sin la libreria Wire ser\u00eda necesario programar funciones como Wire.requestFrom() o Wire.read() , lo que har\u00eda pr\u00e1cticamente inviable desarrollos a corto plazo. La siguiente figura muestra el modelo de capas de abstracci\u00f3n que se est\u00e1 usando: Para el caso del sensor BME280, supondr\u00eda una gran ventaja disponer de una librer\u00eda que ya hiciera todo el trabajo de pedir los datos y convertirlos, con tan solo definir los par\u00e1metros b\u00e1sicos del bus I2C y direcci\u00f3n de esclavo \u2026 y es lo que se ver\u00e1 a continuaci\u00f3n. Como continuar Lo primero es buscar y estudiar las posibilidades, y para esto Arduino facilita la tarea mediante un gestor de librerias, al que se accede a trav\u00e9s de Herramientas > Gestor de librerias \u2026 , obteniendo algo como en la siguiente figura: Como se continuar\u00e1 con el sensor BME280, se pone como filtro de b\u00fasqueda, lo que resultar\u00e1 en algo como: Para la pr\u00e1ctica se ha seleccionado la de SparkFun Electronics , por ser una de las mas completas, configurables y robustas. Esto no significa que no se pueda buscar informaci\u00f3n del resto, probarlas, y sacar conclusiones propias. Pr\u00e1ctica En esta pr\u00e1ctica se busca conseguir una lectura total del sensor BME280 mediante el uso de la librer\u00eda propuesta. Para poder estudiar su uso, ver la documentaci\u00f3n sobre la librer\u00eda BME280 de SparkFun Configuraci\u00f3n y primera lectura Por ahora, se proporciona \u00fanicamente la configuraci\u00f3n, dejando como tarea continuar con el programa \u2026 tras ver lo que dicen sus dise\u00f1adores (documentaci\u00f3n, ejemplos, \u2026) /* Include required headers and/or libraries */ #include <Wire.h> #include \"SparkFunBME280.h\" #define SLAVE_ADDRESS 0x76 /* Instantiate a BME280 object called BME280_obj */ BME280 BME280_obj; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(0, 2); Wire.setClock(400000); /* Address the sensor */ BME280_obj.setI2CAddress(SLAVE_ADDRESS); /* Check communication before continue */ if (BME280_obj.beginI2C(Wire) == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * Ask for the data and print to console here !! * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ /* Ensure not to flood with a huge amount of fast data */ delay(500); }","title":"Pr\u00e1ctica 3 - Uso de librer\u00edas"},{"location":"arduino/practica-03/#practica-3-uso-de-librerias","text":"Tras aprender lo que es el bus I2C y como acceder a los datos en bruto de un dispositivo, en esta pr\u00e1ctica se usar\u00e1 una libreria para que haga ese mismo trabajo. Esto supone una primera ventaja clara: en lugar de necesitar saber los pormenores de un chip, ahora solo ser\u00e1 necesario saber c\u00f3mo se usan las funciones de una librer\u00eda.","title":"Pr\u00e1ctica 3 - Uso de librer\u00edas"},{"location":"arduino/practica-03/#introduccion","text":"Una libreria es uno o varios ficheros de c\u00f3digo en donde ya hay programadas ciertas funcionalidades y se incluyen en el c\u00f3digo en forma de paquete, lo que: Simplificar\u00e1 enormemente el proceso de desarrollo Incrementar\u00e1 la calidad y legibilidad del c\u00f3digo final Necesitar\u00e1 de mucho menos tiempo para obtener los mismos resultados Evitar\u00e1 errores innecesarios, pues normalmente han pasado muchas pruebas Si una libreria falla suele haber alternativas Aunque no se haya estudiado en profundidad, esto ya se ha utilizado en los programas del taller en el momento que se usa, por ejemplo, #include <Wire.h> . Lo que realmente se est\u00e1 haciendo es incluir la cabecera de la librer\u00eda Wire , que dar\u00e1 a conocer al programa una serie de variables, funciones, clases, etc. De esta forma pasan a estar disponibles, y por lo tanto, su funcionalidad. Dicho de otro modo, la librer\u00eda Wire evita tener que leer uno o varios datasheets de un microcontrolador para saber c\u00f3mo hacer funcionar el bus I2C en su forma mas basica. Sin la libreria Wire ser\u00eda necesario programar funciones como Wire.requestFrom() o Wire.read() , lo que har\u00eda pr\u00e1cticamente inviable desarrollos a corto plazo. La siguiente figura muestra el modelo de capas de abstracci\u00f3n que se est\u00e1 usando: Para el caso del sensor BME280, supondr\u00eda una gran ventaja disponer de una librer\u00eda que ya hiciera todo el trabajo de pedir los datos y convertirlos, con tan solo definir los par\u00e1metros b\u00e1sicos del bus I2C y direcci\u00f3n de esclavo \u2026 y es lo que se ver\u00e1 a continuaci\u00f3n.","title":"Introducci\u00f3n"},{"location":"arduino/practica-03/#como-continuar","text":"Lo primero es buscar y estudiar las posibilidades, y para esto Arduino facilita la tarea mediante un gestor de librerias, al que se accede a trav\u00e9s de Herramientas > Gestor de librerias \u2026 , obteniendo algo como en la siguiente figura: Como se continuar\u00e1 con el sensor BME280, se pone como filtro de b\u00fasqueda, lo que resultar\u00e1 en algo como: Para la pr\u00e1ctica se ha seleccionado la de SparkFun Electronics , por ser una de las mas completas, configurables y robustas. Esto no significa que no se pueda buscar informaci\u00f3n del resto, probarlas, y sacar conclusiones propias.","title":"Como continuar"},{"location":"arduino/practica-03/#practica","text":"En esta pr\u00e1ctica se busca conseguir una lectura total del sensor BME280 mediante el uso de la librer\u00eda propuesta. Para poder estudiar su uso, ver la documentaci\u00f3n sobre la librer\u00eda BME280 de SparkFun","title":"Pr\u00e1ctica"},{"location":"arduino/practica-03/#configuracion-y-primera-lectura","text":"Por ahora, se proporciona \u00fanicamente la configuraci\u00f3n, dejando como tarea continuar con el programa \u2026 tras ver lo que dicen sus dise\u00f1adores (documentaci\u00f3n, ejemplos, \u2026) /* Include required headers and/or libraries */ #include <Wire.h> #include \"SparkFunBME280.h\" #define SLAVE_ADDRESS 0x76 /* Instantiate a BME280 object called BME280_obj */ BME280 BME280_obj; /* * Single-pass function to configure the app */ void setup() { /* Start serial for output */ Serial.begin(115200); /* Join I2C bus and set it to 400 kHz */ Wire.begin(0, 2); Wire.setClock(400000); /* Address the sensor */ BME280_obj.setI2CAddress(SLAVE_ADDRESS); /* Check communication before continue */ if (BME280_obj.beginI2C(Wire) == false) { Serial.printf(\"The sensor did not respond. Please check wiring.\\n\"); /* Stop here (WDT will reset at some point) */ while(1); } } /* * Recurrent task, called forever */ void loop() { /* Welcome message! Useful as a control point */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ * Ask for the data and print to console here !! * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ /* Ensure not to flood with a huge amount of fast data */ delay(500); }","title":"Configuraci\u00f3n y primera lectura"},{"location":"arduino/practica-04/","text":"Pr\u00e1ctica 4 TBD","title":"Pr\u00e1ctica 4"},{"location":"arduino/practica-04/#practica-4","text":"TBD","title":"Pr\u00e1ctica 4"},{"location":"hardware/","text":"Hardware Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente. Microcontrolador ESP8266 Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro: Wi-Fi Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip Hardware Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface - Software Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App Placa base: WeMos D1 Mini Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini D\u00f3nde comprar Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link Sensor BME280: Temperatura, humedad y presion Descargar hoja de datos completa BME280 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"Hardware"},{"location":"hardware/#hardware","text":"Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente.","title":"Hardware"},{"location":"hardware/#microcontrolador-esp8266","text":"Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro:","title":"Microcontrolador ESP8266"},{"location":"hardware/#wi-fi","text":"Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip","title":"Wi-Fi"},{"location":"hardware/#hardware_1","text":"Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface -","title":"Hardware"},{"location":"hardware/#software","text":"Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App","title":"Software"},{"location":"hardware/#placa-base-wemos-d1-mini","text":"Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini","title":"Placa base: WeMos D1 Mini"},{"location":"hardware/#donde-comprar","text":"Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-bme280-temperatura-humedad-y-presion","text":"Descargar hoja de datos completa BME280","title":"Sensor BME280: Temperatura, humedad y presion"},{"location":"hardware/#donde-comprar_1","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-mpu6050-giroscopo-de-3-ejes-y-acelerometro-de-3-ejes","text":"Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050","title":"Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes"},{"location":"hardware/#donde-comprar_2","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"D\u00f3nde comprar"},{"location":"introduccion/","text":"Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"introduccion/#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"introduccion/carpeta-de-trabajo/","text":"Carpeta de trabajo TBD","title":"Carpeta de trabajo"},{"location":"introduccion/carpeta-de-trabajo/#carpeta-de-trabajo","text":"TBD","title":"Carpeta de trabajo"},{"location":"lenguaje-c/","text":"Lenguaje C y C99 Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf Tutorial de C/C++ de tenouk.com Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"C"},{"location":"lenguaje-c/#lenguaje-c-y-c99","text":"Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf","title":"Lenguaje C y C99"},{"location":"lenguaje-c/#tutorial-de-cc-de-tenoukcom","text":"Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"Tutorial de C/C++ de tenouk.com"},{"location":"otros-recursos/","text":"Otros recursos Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje. Servidor de apoyo Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Otros recursos"},{"location":"otros-recursos/#otros-recursos","text":"Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje.","title":"Otros recursos"},{"location":"otros-recursos/#servidor-de-apoyo","text":"Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Servidor de apoyo"},{"location":"otros-recursos/mqtt-broker/","text":"MQTT Broker A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone) Install both broker and clients root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker. Configure protocols Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure storage and persistence This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure password file and users Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE Configure access control list (ACL) Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/# Configure clients access Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#mqtt-broker","text":"A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone)","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#install-both-broker-and-clients","text":"root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker.","title":"Install both broker and clients"},{"location":"otros-recursos/mqtt-broker/#configure-protocols","text":"Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure protocols"},{"location":"otros-recursos/mqtt-broker/#configure-storage-and-persistence","text":"This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure storage and persistence"},{"location":"otros-recursos/mqtt-broker/#configure-password-file-and-users","text":"Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE","title":"Configure password file and users"},{"location":"otros-recursos/mqtt-broker/#configure-access-control-list-acl","text":"Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/#","title":"Configure access control list (ACL)"},{"location":"otros-recursos/mqtt-broker/#configure-clients-access","text":"Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure clients access"}]}