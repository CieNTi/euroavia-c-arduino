{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de C y Arduino para Euroavia Sevilla Se dividir\u00e1 en las siguientes secciones: Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados Lenguaje C Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino Hardware Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller Arduino Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Home"},{"location":"#taller-de-c-y-arduino-para-euroavia-sevilla","text":"Se dividir\u00e1 en las siguientes secciones:","title":" Taller de C y Arduino para Euroavia Sevilla"},{"location":"#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"#lenguaje-c","text":"Breve introducci\u00f3n y nociones b\u00e1sicas de C, necesarias antes de adentrarse en Arduino","title":"Lenguaje C"},{"location":"#hardware","text":"Descripci\u00f3n y datos t\u00e9cnicos del hardware que se usar\u00e1 para el taller","title":"Hardware"},{"location":"#arduino","text":"Introducci\u00f3n a Arduino y pr\u00e1cticas","title":"Arduino"},{"location":"arduino/","text":"Introducci\u00f3n a Arduino TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/#introduccion-a-arduino","text":"TBD Enlaces a cada pr\u00e1ctica: Practica 1 - TBD Practica 2 - TBD Practica 3 - TBD Practica 4 - TBD TBD","title":"Introducci\u00f3n a Arduino"},{"location":"arduino/practica-01/","text":"Pr\u00e1ctica 1 TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-01/#practica-1","text":"TBD","title":"Pr\u00e1ctica 1"},{"location":"arduino/practica-02/","text":"Pr\u00e1ctica 2 - El bus I2C Introducci\u00f3n Antes de comenzar, se debe entender el concepto de bus: De Wikipedia : En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre chips, denominandose Inter Integrated Circuits bus o IIC, acabando posteriormente como I2C. Es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir esa comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan en paralelo compartiendo las lineas de alimentaci\u00f3n y dos espec\u00edficas, SCL (Linea de reloj) y SDA (Linea de datos), como se ve en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, en caso de querer saberlos se deja como referencia el documento oficial de NXP (antes Philips). Descargar I2C-bus specification and user manual (UM10204) Pr\u00e1ctica En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con los dispositivos I2C acoplados al D1 Mini: BME280 : Sensor de temperatura, humedad y presi\u00f3n MPU6050 : Giroscopo de 3 ejes y acelerometro de 3 ejes El montaje proporcionado equivale al siguiente esquem\u00e1tico: La librer\u00eda I2C, en Arduino se llama Wire, y gestiona el protocolo de comunicaciones completo, lo que es un detalle, pues nos ahorra la parte de estudiar el protocolo y escribir programas para ello (maquina de estados a bajo nivel). Esto es una practica habitual y recomendada, construir sobre el trabajo de terceros. Es una de las muy grandes virtudes de la comunidad Arduino y open source. Hay una gama muy amplia de librerias que dan soporte a muchisimos dispositivos, o crean funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso. Programa Se parte de la anterior sesi\u00f3n, donde un programa enviaba por puerto serie 3 variables, para luego verlas o dibujarlas mediante el monitor serie o el plotter, respectivamente. Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. Disponible en https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Libreria Wire de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. Disponible en https://www.arduino.cc/en/reference/wire Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful to know where */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: %02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no ser\u00e1 posible una comunicaci\u00f3n, al no existir un esclavo con la direcci\u00f3n 0x12 , lo que llevar\u00e1 al siguiente paso: Estudiar los dispositivos En el caso del BME280, tras leer su datasheet, vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , segun si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo aun no responda, por lo que el dato se acabar\u00eda perdiendo. Para esto existe Wire.available() . Incluyendo ambos datos, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful to know where */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: %02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Si nos fijamos bien, no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato concreto y controlado, es necesario direccionarlo primero. Es tarea del alumno continuar a partir de aqui, confirmando primero una comunicaci\u00f3n adecuada, y obteniendo posteriormente los datos de temperatura, humedad y presi\u00f3n (necesitando por tanto recibir mas de un byte en una tanda). Estos datos se presentar\u00e1n por pantalla tras su lectura, como ha quedado reflejado en el ejemplo. NOTA : Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n. El siguiente paso, ser\u00e1 comunicarnos con el MPU-6050 de la misma forma.","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#practica-2-el-bus-i2c","text":"","title":"Pr\u00e1ctica 2 - El bus I2C"},{"location":"arduino/practica-02/#introduccion","text":"Antes de comenzar, se debe entender el concepto de bus: De Wikipedia : En arquitectura de computadores, el bus (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Est\u00e1 formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, adem\u00e1s de circuitos integrados. Existen dos tipos de transferencia en los buses: Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un \u00fanico cable que transmite la informaci\u00f3n. Paralelo: El bus permite transferir varios bits simult\u00e1neamente, por ejemplo 8 bits. Aunque en primera instancia parece mucho m\u00e1s eficiente la transferencia en paralelo, esta presenta inconvenientes: La frecuencia de reloj en el bus paralelo tiene que ser m\u00e1s reducida. La longitud de los cables que forman el bus est\u00e1 limitada por las posibles interferencias, el ruido y los retardo en la se\u00f1al. Adem\u00e1s, los modernos buses serie est\u00e1n formados por varios canales: En este caso se transmite por varios buses serie simult\u00e1neamente. El bus I2C surge como una soluci\u00f3n de comunicaci\u00f3n entre chips, denominandose Inter Integrated Circuits bus o IIC, acabando posteriormente como I2C. Es una norma que especifica la velocidad, niveles de tensi\u00f3n, y el protocolo a seguir para conseguir esa comunicaci\u00f3n. Se basa en una comunicaci\u00f3n de tipo Maestro-Esclavo, donde varios chips se conectan en paralelo compartiendo las lineas de alimentaci\u00f3n y dos espec\u00edficas, SCL (Linea de reloj) y SDA (Linea de datos), como se ve en la siguiente figura: El maestro, cuando quiera iniciar una comunicaci\u00f3n, establecer\u00e1 una frecuencia en la l\u00ednea de SCL, que normalmente ser\u00e1 100 kHz o 400 kHz, e iniciar\u00e1 la comunicaci\u00f3n como corresponda a traves de la linea SDA. Dicha comunicaci\u00f3n se har\u00e1 localizada a un chip concreto, mediante su direcci\u00f3n de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos. Para no alargar la introducci\u00f3n entrando en detalles t\u00e9cnicos de nivel mas bajo, en caso de querer saberlos se deja como referencia el documento oficial de NXP (antes Philips). Descargar I2C-bus specification and user manual (UM10204)","title":"Introducci\u00f3n"},{"location":"arduino/practica-02/#practica","text":"En esta pr\u00e1ctica se busca conseguir una comunicaci\u00f3n a traves del bus I2C con los dispositivos I2C acoplados al D1 Mini: BME280 : Sensor de temperatura, humedad y presi\u00f3n MPU6050 : Giroscopo de 3 ejes y acelerometro de 3 ejes El montaje proporcionado equivale al siguiente esquem\u00e1tico: La librer\u00eda I2C, en Arduino se llama Wire, y gestiona el protocolo de comunicaciones completo, lo que es un detalle, pues nos ahorra la parte de estudiar el protocolo y escribir programas para ello (maquina de estados a bajo nivel). Esto es una practica habitual y recomendada, construir sobre el trabajo de terceros. Es una de las muy grandes virtudes de la comunidad Arduino y open source. Hay una gama muy amplia de librerias que dan soporte a muchisimos dispositivos, o crean funcionalidades nuevas, \u2026 Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso.","title":"Pr\u00e1ctica"},{"location":"arduino/practica-02/#programa","text":"Se parte de la anterior sesi\u00f3n, donde un programa enviaba por puerto serie 3 variables, para luego verlas o dibujarlas mediante el monitor serie o el plotter, respectivamente. Librerias ESP8266 para Ardu\u00edno : Se debe consultar para saber como manejar los perif\u00e9ricos del micro. Disponible en https://arduino-esp8266.readthedocs.io/en/latest/libraries.html Libreria Wire de Arduino : Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo gen\u00e9rico en todos los Arduino. Disponible en https://www.arduino.cc/en/reference/wire Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria Wire , al principio de nuestro programa, de la siguiente forma: /* Include required headers and/or libraries */ #include <Wire.h> Incluir su inicializaci\u00f3n en la secci\u00f3n de setup: /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } Y por \u00faltimo, pedir un dato a alg\u00fan dispositivo esclavo en el bucle principal, mostr\u00e1ndolo por pantalla para saber que est\u00e1 bien: /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful to know where */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x12 */ Wire.requestFrom(0x12, 1); /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: %02X\\n\", c); /* Ensure not to flood with a huge amount of fast data */ delay(500); } Al lanzar el programa no ser\u00e1 posible una comunicaci\u00f3n, al no existir un esclavo con la direcci\u00f3n 0x12 , lo que llevar\u00e1 al siguiente paso: Estudiar los dispositivos En el caso del BME280, tras leer su datasheet, vemos como la direcci\u00f3n asociada ser\u00e1 0x76 o 0x77 , segun si uno de sus pines est\u00e1 puesto a GND o a Vcc. En el caso de la placa de pr\u00e1cticas, este pin est\u00e1 en GND por lo que la direcci\u00f3n final queda como 0x76 . Otro punto a tener en cuenta es que no se est\u00e1 controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo aun no responda, por lo que el dato se acabar\u00eda perdiendo. Para esto existe Wire.available() . Incluyendo ambos datos, nuestro nuevo programa quedar\u00eda como: /* Include required headers and/or libraries */ #include <Wire.h> /* Single-pass function to configure the app */ void setup() { /* Join i2c bus (address optional for master) */ Wire.begin(0, 2); /* start serial for output */ Serial.begin(115200); } /* Recurrent task, called forever */ void loop() { /* Welcome message! Useful to know where */ Serial.printf(\"Ahoy! ESP8266 here!\\n---\\n\"); /* Request data from slave with address 0x76 */ Wire.requestFrom(0x76, 1); /* Wait for data to be available */ while (Wire.available()) { /* Receive the byte */ uint8_t c = Wire.read(); /* Send it to console/monitor */ Serial.printf(\"Received byte: %02X\\n\", c); } /* Ensure not to flood with a huge amount of fast data */ delay(500); } Si nos fijamos bien, no estamos controlando qu\u00e9 dato pedimos, simplemente \u201cleemos un byte\u201d. Para poder pedir un dato concreto y controlado, es necesario direccionarlo primero. Es tarea del alumno continuar a partir de aqui, confirmando primero una comunicaci\u00f3n adecuada, y obteniendo posteriormente los datos de temperatura, humedad y presi\u00f3n (necesitando por tanto recibir mas de un byte en una tanda). Estos datos se presentar\u00e1n por pantalla tras su lectura, como ha quedado reflejado en el ejemplo. NOTA : Para confirmar la comunicaci\u00f3n se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o Chip ID . Ver la secci\u00f3n dedicada al BME280 para mas informaci\u00f3n. El siguiente paso, ser\u00e1 comunicarnos con el MPU-6050 de la misma forma.","title":"Programa"},{"location":"arduino/practica-03/","text":"Pr\u00e1ctica 3 TBD","title":"Pr\u00e1ctica 3"},{"location":"arduino/practica-03/#practica-3","text":"TBD","title":"Pr\u00e1ctica 3"},{"location":"arduino/practica-04/","text":"Pr\u00e1ctica 4 TBD","title":"Pr\u00e1ctica 4"},{"location":"arduino/practica-04/#practica-4","text":"TBD","title":"Pr\u00e1ctica 4"},{"location":"hardware/","text":"Hardware Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente. Microcontrolador ESP8266 Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro: Wi-Fi Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip Hardware Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface - Software Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App Placa base: WeMos D1 Mini Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini D\u00f3nde comprar Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link Sensor BME280: Temperatura, humedad y presion Descargar hoja de datos completa BME280 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050 D\u00f3nde comprar Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"Hardware"},{"location":"hardware/#hardware","text":"Tras analizar la oferta actual de placas de desarrollo soportados por Arduino, en base a su conectividad, tama\u00f1o y peso, se opt\u00f3 por la placa D1 Mini de WeMos , basada en un chip ESP8266 . En l\u00edneas generales esta placa ofrece un equilibrio entre tama\u00f1o y peso frente a conectividad y posibilidades, ya que aparte de integrar un chipset Wi-Fi, es posible programarla sin ning\u00fan dispositivo extra y gracias a su arquitectura interna, pr\u00e1cticamente todos los GPIOs son reprogramables, pudiendose intercambiar las funcionalidades de Serie, I2C, SPI, \u2026 Tambien se estudia que sens\u00f3rica a\u00f1adir, siempre que estuviera disponible en formato placa de desarrollo para evitar la soldadura SMD, seleccionando finalmente los sensores BME280 y MPU6050, temperatura/humedad/presion y aceler\u00f3metro/gir\u00f3scopo, respectivamente. Puesto que no se necesita ning\u00fan otro elemento para que pueda funcionar, se monta cada sensor en el bus I2C, que desde el punto de vista esquem\u00e1tico queda como: A continuaci\u00f3n se presenta informaci\u00f3n b\u00e1sica y enlaces a documentaci\u00f3n de cada uno de los elementos, siendo lo necesario para poder entenderlos y programarlos adecuadamente.","title":"Hardware"},{"location":"hardware/#microcontrolador-esp8266","text":"Descargar hoja de datos completa ESP8266EX Se indican a continuaci\u00f3n las caracteristicas generales del micro:","title":"Microcontrolador ESP8266"},{"location":"hardware/#wi-fi","text":"Items Parameters Certification Wi-Fi Alliance Protocols 802.11 b/g/n (HT20) Frequency Range 2.4G ~ 2.5G (2400M ~ 2483.5M) TX Power 802.11 b: +20 dBm 802.11 g: +17 dBm 802.11 n: +14 dBm Rx Sensitivity 802.11 b: \u201391 dbm (11 Mbps) 802.11 g: \u201375 dbm (54 Mbps) 802.11 n: \u201372 dbm (MCS7) Antenna PCB Trace, External, IPEX Connector, Ceramic Chip","title":"Wi-Fi"},{"location":"hardware/#hardware_1","text":"Items Parameters CPU Tensilica L106 32-bit processor Peripheral Interface UART/SDIO/SPI/I2C/I2S/IR Remote Control GPIO/ADC/PWM/LED Light & Button Operating Voltage 2.5V ~ 3.6V Operating Current Average value: 80 mA Operating Temperature Range \u201340\u00b0C ~ 125\u00b0C Package Size QFN32-pin (5 mm x 5 mm) External Interface -","title":"Hardware"},{"location":"hardware/#software","text":"Items Parameters Wi-Fi Mode Station/SoftAP/SoftAP+Station Security WPA/WPA2 Encryption WEP/TKIP/AES Firmware Upgrade UART Download / OTA (via network) Software Development Supports Cloud Server Development / Firmware and SDK Network Protocols IPv4, TCP/UDP/HTTP User Configuration AT Instruction Set, Cloud Server, Android/iOS App","title":"Software"},{"location":"hardware/#placa-base-wemos-d1-mini","text":"Descargar esquem\u00e1tico D1 Mini Pagina oficial de la placa D1 Mini","title":"Placa base: WeMos D1 Mini"},{"location":"hardware/#donde-comprar","text":"Item Cantidad Precio Precio Ud. Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon D1 Mini 5 22.99 4.6 25.6 34.2 10 3 Link D1 Mini 3 14.99 5 25.6 34.2 10 3 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-bme280-temperatura-humedad-y-presion","text":"Descargar hoja de datos completa BME280","title":"Sensor BME280: Temperatura, humedad y presion"},{"location":"hardware/#donde-comprar_1","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo BME280 5 26.12 5.23 (+0.53/-0.67) No, linea unica 10 12 5 1 Link Modulo BME280 5 26.99 5.4 (+0.7/-0.5) No, linea unica 10 12 5 1 Link","title":"D\u00f3nde comprar"},{"location":"hardware/#sensor-mpu6050-giroscopo-de-3-ejes-y-acelerometro-de-3-ejes","text":"Descargar hoja de datos parcial MPU6050 Descargar mapa de registros MPU6050","title":"Sensor MPU6050: Giroscopo de 3 ejes y aceler\u00f3metro de 3 ejes"},{"location":"hardware/#donde-comprar_2","text":"Item Cantidad Precio Precio Ud. Pinout compatible D1 Mini Ancho (mm) Alto (mm) Grosor (mm) Peso (g) Link Amazon Modulo MPU-6050 6 14.29 2.4 No, linea unica 20 16 5 1 Link Modulo MPU-6050 10 31.99 3.2 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.31 4.43 No, linea unica 20 16 5 1 Link Modulo MPU-6050 3 13.37 4.46 No, linea unica 20 16 5 1 Link","title":"D\u00f3nde comprar"},{"location":"introduccion/","text":"Introducci\u00f3n Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"introduccion/#introduccion","text":"Presentaci\u00f3n de las aplicaciones y herramientas que ser\u00e1n necesarias a lo largo del taller, asi como de los objetivos esperados","title":"Introducci\u00f3n"},{"location":"lenguaje-c/","text":"Lenguaje C y C99 Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf Tutorial de C/C++ de tenouk.com Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"C"},{"location":"lenguaje-c/#lenguaje-c-y-c99","text":"Hay varios estandares que se pueden seguir para programar en C/C++, pero es muy aconsejable ce\u00f1irse a C99 mientras sea posible, ya que asegurar\u00e1 una compatibilidad enorme entre diferentes sistemas. Descargar est\u00e1ndar ISO-IEC-9899_C99-Standard.pdf","title":"Lenguaje C y C99"},{"location":"lenguaje-c/#tutorial-de-cc-de-tenoukcom","text":"Fuente : Link a la pagina de descarga de donde se han sacado estos PDF Se incluyen los siguientes ficheros para facilitar la disponibilidad de estos en cada puesto de trabajo. El usuario solo tendra que utilizar git y descargar la rama para poder acceder a este contenido. Igualmente se enlazan desde aqui para facilitar la navegacion web: M\u00f3dulo 1: C / C++ Introduction. Intro and history, building and running the first C/C++ program M\u00f3dulo 2: C / C++ Basic Data Types [1/2/3]. The basic C & C++ data types story and program examples M\u00f3dulo 3: C / C++ Statements, Expressions & Operators [1/2/3]. Statements, expressions and operators used in C & C++ story and program examples M\u00f3dulo 4: C / C++ Functions [1/2/3/4]. Functions story and program examples M\u00f3dulo 5: C Formatted I/O [1/2]. The printf() and scanf() story and program examples M\u00f3dulo 6: C / C++ Program Controls [1/2]. Loops, if-else, while, do-while, for, switch-case-break etc. story and program examples M\u00f3dulo 7: C / C++ Arrays [1/2]. Array or aggregated data type, story and program examples M\u00f3dulo 8: C / C++ Pointers [1/2/3]. Pointers, another very important data type, story and program examples M\u00f3dulo 9: C File I/O [1/2/3]. Standard file input/output, creating, reading and writing files, story and program examples M\u00f3dulo 10: C / C++ Preprocessor Directives. Preprocessor directives used in C/C++, #include, macros, inline functions etc M\u00f3dulo 11: C / C++ Type Specifiers. struct, typedef, union & enum - Various C/C++ aggregated data types and typedef M\u00f3dulo W: Assembler, Compiler & Linker. Quite a complete story how C assembled, compiled, linked and run M\u00f3dulo X: C\u2019s Character and String Manipulation. Using standard C predefined functions in manipulating characters and strings, full of working program examples M\u00f3dulo Y: main() and Command Line Arguments. A complete story of the main() function M\u00f3dulo : C Storage and Memory Allocation. Predefined functions used in memory allocation and de-allocation in C","title":"Tutorial de C/C++ de tenouk.com"},{"location":"otros-recursos/","text":"Otros recursos Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje. Servidor de apoyo Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Otros recursos"},{"location":"otros-recursos/#otros-recursos","text":"Este apartado contiene informaci\u00f3n adicional que ha sido necesaria o est\u00e1 relacionada con el taller. Los alumnos no necesitan estudiar esta parte, ni tampoco se expondr\u00e1 en clases, pero queda a disposici\u00f3n por si surgen dudas o por pura curiosidad y aprendizaje.","title":"Otros recursos"},{"location":"otros-recursos/#servidor-de-apoyo","text":"Se ha levantado un servidor con SO Debian 9, accesible a traves de iot.tesla.studio , para que sirva como apoyo en todo lo que a presencia online se refiera. Roadmap: MQTT Broker - Informaci\u00f3n t\u00e9cnica de la instalaci\u00f3n del broker MQTT Dashboard (TBD) - Informaci\u00f3n t\u00e9cnica de la presentaci\u00f3n via web de los datos recogidos por MQTT","title":"Servidor de apoyo"},{"location":"otros-recursos/mqtt-broker/","text":"MQTT Broker A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone) Install both broker and clients root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker. Configure protocols Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure storage and persistence This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status Configure password file and users Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE Configure access control list (ACL) Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/# Configure clients access Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#mqtt-broker","text":"A MQTT Broker is configured for Euroavia C/Arduino workshop. The provided ESP8266-based boards will be able to publish generic and sensor data to this server. Address: iot.tesla.studio MQTT port: 1883 WebSocket port: 1884 MQTT URI: mqtt://iot.tesla.studio:1883 WebSockeet URI: ws://iot.tesla.studio:1884 Available topics and privacy for this devices: Topic path Description euroavia-pool/# Subscribe access to any device (public pool) euroavia-pool/USERNAME/# Subscribe/Publish access to a specific path (public pool) euroavia-devices/USERNAME/# Subscribe/Publish access (private zone)","title":"MQTT Broker"},{"location":"otros-recursos/mqtt-broker/#install-both-broker-and-clients","text":"root@iot:~# apt-get install mosquitto mosquitto-clients root@iot:~# service mosquitto status If OK will look like this: \u25cf mosquitto.service - LSB: mosquitto MQTT v3.1 message broker Loaded: loaded (/etc/init.d/mosquitto; generated; vendor preset: enabled) Active: active (running) since Fri 2019-03-29 00:52:35 CET; 7s ago Docs: man:systemd-sysv-generator(8) CGroup: /system.slice/mosquitto.service \u2514\u25004806 /usr/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf Mar 29 00:52:35 iot systemd[1]: Starting LSB: mosquitto MQTT v3.1 message broker... Mar 29 00:52:35 iot mosquitto[4801]: Starting network daemon:: mosquitto. Mar 29 00:52:35 iot systemd[1]: Started LSB: mosquitto MQTT v3.1 message broker.","title":"Install both broker and clients"},{"location":"otros-recursos/mqtt-broker/#configure-protocols","text":"Enable both MQTT and WebSockets protocols root@iot:~# cat /etc/mosquitto/conf.d/protocols.conf listener 1883 protocol mqtt listener 1884 protocol websockets Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure protocols"},{"location":"otros-recursos/mqtt-broker/#configure-storage-and-persistence","text":"This allows the broker to keep the data even between restarts root@iot:~# cat /etc/mosquitto/conf.d/storage.conf persistence true persistence_location /var/lib/mosquitto/ persistence_file mosquitto.db Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure storage and persistence"},{"location":"otros-recursos/mqtt-broker/#configure-password-file-and-users","text":"Add first (-c), then in batch (-b). Use (-D) for user deletion root@iot:~# mosquitto_passwd -c /etc/mosquitto/passwd web_client root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0001 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0002 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0003 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0004 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0005 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0006 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0007 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0008 PASSHERE root@iot:~# mosquitto_passwd -b /etc/mosquitto/passwd tc_d1_0000 PASSHERE","title":"Configure password file and users"},{"location":"otros-recursos/mqtt-broker/#configure-access-control-list-acl","text":"Create rules for clients with and without username root@iot:~# cat /etc/mosquitto/aclfile # # Clients without username # # This affects access control for clients with no username. topic read $SYS/# # # Clients with username # ## Main users: admin and web_client user admin topic readwrite # user web_client topic read # ## Other users: TC-Euroavia pattern readwrite euroavia-pool/%u/# pattern read euroavia-pool/# pattern readwrite euroavia-devices/%u/#","title":"Configure access control list (ACL)"},{"location":"otros-recursos/mqtt-broker/#configure-clients-access","text":"Enable both password and ACL root@iot:~# cat /etc/mosquitto/conf.d/access.conf allow_anonymous false password_file /etc/mosquitto/passwd acl_file /etc/mosquitto/aclfile Restart the server and check status root@iot:~# service mosquitto restart root@iot:~# service mosquitto status","title":"Configure clients access"}]}