<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Contenido del taller impartido para Euroavia Sevilla de C y Arduino sobre LOLIN-WeMos D1 Mini - ESP8266">
    <meta name="author" content="CieNTi">
    
    <link rel="../../img/favicon.ico">

    
    <title>Práctica 2 - El bus I2C - Taller de C y Arduino</title>
    

    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">
    <link href="../../css/highlight.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.28/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="../..">Taller de C y Arduino</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Introducción <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../introduccion/">Introducción</a>
</li>

                        
                            
<li >
    <a href="../../introduccion/carpeta-de-trabajo/">Carpeta de trabajo</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../../lenguaje-c/">C</a>
                    </li>
                
                
                
                    <li >
                        <a href="../../hardware/">Hardware</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Arduino <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../">Introducción a Arduino</a>
</li>

                        
                            
<li >
    <a href="../practica-01/">Práctica 1</a>
</li>

                        
                            
<li class="active">
    <a href="./">Práctica 2 - El bus I2C</a>
</li>

                        
                            
<li >
    <a href="../practica-03/">Práctica 3</a>
</li>

                        
                            
<li >
    <a href="../practica-04/">Práctica 4</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Otros recursos <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../otros-recursos/">Otros recursos</a>
</li>

                        
                            
<li >
    <a href="../../otros-recursos/mqtt-broker/">MQTT Broker</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../practica-01/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../practica-03/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/euroavia-sevilla/curso-c-arduino/edit/master/workshop/arduino/practica-02/README.md"><i class="fab fa-github"></i> Edit on GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#practica-2-el-bus-i2c">Práctica 2 - El bus I2C</a></li>
            <li class="second-level"><a href="#introduccion">Introducción</a></li>
                
            <li class="second-level"><a href="#como-continuar">Como continuar</a></li>
                
            <li class="second-level"><a href="#practica">Práctica</a></li>
                
                <li class="third-level"><a href="#primera-comunicacion-i2c">Primera comunicación I2C</a></li>
                <li class="third-level"><a href="#leer-un-byte">Leer un byte</a></li>
                <li class="third-level"><a href="#leer-de-una-direccion-concreta">Leer de una dirección concreta</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="practica-2-el-bus-i2c">Práctica 2 - El bus I2C</h1>
<h2 id="introduccion">Introducción</h2>
<p>Antes de comenzar, se debe entender el concepto de bus:</p>
<blockquote>
<p>En arquitectura de computadores, el <strong>bus</strong> (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Está formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, además de circuitos integrados.</p>
<p>Existen dos tipos de transferencia en los buses:</p>
<ul>
<li>Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un único cable que transmite la información.</li>
<li>Paralelo: El bus permite transferir varios bits simultáneamente, por ejemplo 8 bits.</li>
</ul>
<p>Aunque en primera instancia parece mucho más eficiente la transferencia en paralelo, esta presenta inconvenientes:</p>
<ul>
<li>La frecuencia de reloj en el bus paralelo tiene que ser más reducida.</li>
<li>La longitud de los cables que forman el bus está limitada por las posibles interferencias, el ruido y los retardo en la señal.</li>
</ul>
<p>Además, los modernos buses serie están formados por varios canales: En este caso se transmite por varios buses serie simultáneamente. </p>
<p><small><a href="https://es.wikipedia.org/wiki/Bus_(inform%C3%A1tica)">Wikipedia</a></small></p>
</blockquote>
<p>El <strong>bus I2C</strong> surge como una solución de comunicación entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensión, y el protocolo a seguir para conseguir dicha comunicación.</p>
<p>Se basa en una comunicación de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentación, Vcc y GND, y dos específicas, SCL (linea de reloj) y SDA (linea de datos).</p>
<p>Esto mismo se representa en la siguiente figura:</p>
<p><img alt="Diagrama de conexión I2C" src="I2C-diagram.jpg" /></p>
<p>El maestro, cuando quiera iniciar una comunicación, establecerá una frecuencia en la línea de SCL, que normalmente será 100 kHz o 400 kHz, e iniciará la comunicación como corresponda a traves de la linea SDA.</p>
<p>Dicha comunicación se hará localizada a un chip concreto, mediante su dirección de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos.</p>
<p>Para no alargar la introducción entrando en detalles técnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No será necesaria su lectura para la práctica, pero no está de mas tener a mano la documentación de cada parte para casos de duda, aprendizaje o pura curiosidad.</p>
<blockquote>
<p>Descargar <a href="UM10204.pdf"><i class="fa fa-cloud-download-alt" style="color:#FA023C"></i> I2C-bus specification and user manual (UM10204)</a></p>
</blockquote>
<h2 id="como-continuar">Como continuar</h2>
<p>Lo siguiente será informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraerá todo el bajo nivel a modo de funciones incluidas mediante librerías.</p>
<blockquote>
<p>El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino.</p>
<p>Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, &hellip;</p>
<p>Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso.</p>
</blockquote>
<p>Dichas librerias pueden ser parte del conjunto estándar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librería que da soporte Arduino al chip <em>ESP8266</em> (de otro modo, no sería posible trabajar con el entorno de Arduino y la placa proporcionada).</p>
<p>Para poder usarlas es necesario leer su documentacion de antemano, que se compone de:</p>
<ol>
<li><strong>Librerias ESP8266 para Arduíno</strong>: Se debe consultar para saber como manejar los periféricos del micro.  <br />
<a href="https://arduino-esp8266.readthedocs.io/en/latest/libraries.html">https://arduino-esp8266.readthedocs.io/en/latest/libraries.html</a></li>
<li><strong>Librerias de Arduino</strong>: Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo genérico en todos los Arduino.  <br />
<a href="https://www.arduino.cc/en/Reference/Libraries">https://www.arduino.cc/en/Reference/Libraries</a></li>
</ol>
<p>Como se indica, se recomienda primero ver la parte específica y luego la general, ya que tendrá preferencia en el momento de su uso. Esto pasa con la funcion <code>Wire.begin()</code>:</p>
<p><code>Wire.begin()</code> existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusión aunque el programa sea totalmente correcto.</p>
<p>Lo correcto será usar <code>Wire.begin()</code> como dicta la libreria del ESP8266: <a href="https://arduino-esp8266.readthedocs.io/en/latest/libraries.html#i2c-wire-library">Wire.begin(SDA_pin, SCL_pin)</a>. Esto arrancará el periférico I2C en modo maestro usando concrétamente esos pines.</p>
<p>Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usarán como dicta la libreria <code>Wire</code> de Arduino.</p>
<h2 id="practica">Práctica</h2>
<p>En esta práctica se busca conseguir una comunicación a traves del bus I2C con el dispositivo <a href="../../hardware/#sensor-bme280-temperatura-humedad-y-presion"><i class="fa fa-link" style="color:#FA023C"></i> BME280</a> acoplado al D1 Mini.</p>
<p>Para referencia, el montaje proporcionado equivale al siguiente esquemático:</p>
<p><img alt="D1-and-sensors.png" src="../../hardware/D1-and-sensors.png" /></p>
<h3 id="primera-comunicacion-i2c">Primera comunicación I2C</h3>
<p>Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria <code>Wire</code>, al principio de nuestro programa, de la siguiente forma:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;
</code></pre>

<p>Incluir su inicialización en la sección de setup:</p>
<pre><code class="C">/* Single-pass function to configure the app */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* Start serial for output */
  Serial.begin(115200);
}
</code></pre>

<p>Y por último, pedir un dato a algún dispositivo esclavo en el bucle principal, mostrándolo por pantalla para saber que está bien:</p>
<pre><code class="C">/* Recurrent task, called forever */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Request data from slave with address 0x12 */
  Wire.requestFrom(0x12, 1);

  /* Receive the byte */
  uint8_t c = Wire.read();

  /* Send it to console/monitor */
  Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p>Al lanzar el programa no se llevará a cabo una comunicación válida por no existir un esclavo con la dirección <code>0x12</code>, lo que deja la duda de .. <em>entonces cual es la correcta?</em>.</p>
<p>Para responderla es necesario <strong>estudiar los dispositivos</strong>, documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante.</p>
<h3 id="leer-un-byte">Leer un byte</h3>
<p>En el caso del BME280, tras leer <a href="../../hardware/BME280_datasheet_en.pdf"><i class="fa fa-link" style="color:#FA023C"></i> su datasheet</a>, vemos como la dirección asociada será <code>0x76</code> o <code>0x77</code>, según si uno de sus pines está puesto a GND o a Vcc. En el caso de la placa de prácticas, este pin está en GND por lo que la dirección final queda como <code>0x76</code>.</p>
<p>Otro punto a tener en cuenta es que no se está controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder.</p>
<p>Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no estén sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la función <a href="https://www.arduino.cc/en/Reference/WireAvailable">Wire.available()</a>.</p>
<p>Incluyendo ambos cambios, nuestro nuevo programa quedaría como:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;

/* Single-pass function to configure the app */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* start serial for output */
  Serial.begin(115200);
}

/* Recurrent task, called forever */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Request data from slave with address 0x76 */
  Wire.requestFrom(0x76, 1);

  /* Wait for data to be available */
  while (Wire.available())
  {
    /* Receive the byte */
    uint8_t c = Wire.read();

    /* Send it to console/monitor */
    Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);
  }

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p><small><em>Ver sketch <a href="https://github.com/euroavia-sevilla/curso-c-arduino/tree/master/arduino/sketch/BME280_available-byte/BME280_available-byte.ino"><i class="fab fa-github" style="color:#FA023C"></i> BME280_available-byte.ino</a> en GitHub</em></small></p>
<p>El programa debería imprimir por puerto serie algo parecido a:</p>
<pre><code class="text">Ahoy! ESP8266 here!
---
Received byte: 0x03
Ahoy! ESP8266 here!
---
Received byte: 0x1E
Ahoy! ESP8266 here!
---
Received byte: 0x27
Ahoy! ESP8266 here!
---
Received byte: 0x41
</code></pre>

<p>Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicará que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa automáticamente con cada lectura, y se reinicia llegado a un tope.</p>
<h3 id="leer-de-una-direccion-concreta">Leer de una dirección concreta</h3>
<p>Si nos fijamos bien, en el ejemplo anterior no estamos controlando qué dato pedimos, simplemente &ldquo;leemos un byte&rdquo;.</p>
<p>Para poder pedir un dato de una dirección concreta es necesario direccionarlo primero. De nuevo <a href="../../hardware/BME280_datasheet_en.pdf"><i class="fa fa-link" style="color:#FA023C"></i> su datasheet</a> detalla cómo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas.</p>
<p><img alt="BME280_read-addressing.png" src="BME280_read-addressing.png" /></p>
<p>Interpretándola, será necesario:</p>
<ol>
<li>Hacer una escritura, en la que el dato enviado será la dirección de la que queremos leer</li>
<li>El BME280 internamente reposicionará su puntero de memoria.</li>
<li>Entonces se procede a la lectura</li>
<li>Ahora es cuando el BME280 devolverá los datos almacenados a partir de la dirección pedida</li>
</ol>
<p>Si en lugar de varios queremos un único byte, simplemente tendremos que pedir un único byte <i class="far fa-smile"></i>.</p>
<blockquote>
<p>Para confirmar la comunicación se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o <strong>Chip ID</strong>, localizado en la dirección <code>0xD0</code>.</p>
<p><small><a href="../../hardware/#sensor-bme280-temperatura-humedad-y-presion">Ver la sección dedicada al BME280</a> para mas información</small></p>
</blockquote>
<p>Si todo esto se traduce a código, lo visto quedaría como:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;

/*
 * Single-pass function to configure the app
 */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* start serial for output */
  Serial.begin(115200);
}

/*
 * Recurrent task, called forever
 */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Tell the BME280 where we want to read */
  Wire.beginTransmission(0x76);
  Wire.write(0xD0);
  Wire.endTransmission();

  /* Request data from slave with address 0x76 */
  Wire.requestFrom(0x76, 1);

  /* Wait for data to be available */
  while (Wire.available())
  {
    /* Receive the byte */
    uint8_t c = Wire.read();

    /* Send it to console/monitor */
    Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);
  }

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p><small><em>Ver sketch <a href="https://github.com/euroavia-sevilla/curso-c-arduino/tree/master/arduino/sketch/BME280_available-byte/BME280_byte-addressing.ino"><i class="fab fa-github" style="color:#FA023C"></i> BME280_byte-addressing.ino</a> en GitHub</em></small></p>
<p>El programa debería imprimir por puerto serie exáctamente lo siguiente:</p>
<pre><code class="text">Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
</code></pre>

<p>Que indicará que se ha leído correctamente el identificador de chip, localizado en la dirección <code>0xD0</code>, con el valor esperado de <code>0x60</code>.</p></div>
        
        
    </div>

    <footer class="col-md-12 text-center">
        
        <hr>
        <p>
        <small>2019 - CieNTi - Euroavia Sevilla<br></small>
        
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>

        
        
    </footer>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '../..';
    </script>
    <script src="../../js/base.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
