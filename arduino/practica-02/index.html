<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Contenido del taller impartido para Euroavia Sevilla de C y Arduino sobre LOLIN-WeMos D1 Mini - ESP8266">
    <meta name="author" content="CieNTi">
    
    <link rel="../../img/favicon.ico">

    
    <title>Práctica 2 - El bus I2C - Taller de C y Arduino</title>
    

    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">
    <link href="../../css/highlight.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.28/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="../..">Taller de C y Arduino</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Introducción <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../introduccion/">Introducción</a>
</li>

                        
                            
<li >
    <a href="../../introduccion/carpeta-de-trabajo/">Carpeta de trabajo</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">C <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../lenguaje-c/">Lenguaje C y C99</a>
</li>

                        
                            
<li >
    <a href="../../lenguaje-c/punteros/">Punteros</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li >
                        <a href="../../hardware/">Hardware</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Arduino <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../">Introducción a Arduino</a>
</li>

                        
                            
<li >
    <a href="../practica-01/">Práctica 1</a>
</li>

                        
                            
<li class="active">
    <a href="./">Práctica 2 - El bus I2C</a>
</li>

                        
                            
<li >
    <a href="../practica-03/">Práctica 3 - Uso de librerías</a>
</li>

                        
                            
<li >
    <a href="../practica-04/">Práctica 4</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Otros recursos <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../otros-recursos/">Otros recursos</a>
</li>

                        
                            
<li >
    <a href="../../otros-recursos/mqtt-broker/">MQTT Broker</a>
</li>

                        
                            
<li >
    <a href="../../otros-recursos/chart-frontend/">Introducción</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../practica-01/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../practica-03/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/euroavia-sevilla/curso-c-arduino/edit/master/workshop/arduino/practica-02/README.md"><i class="fab fa-github"></i> Edit on GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#practica-2-el-bus-i2c">Práctica 2 - El bus I2C</a></li>
            <li class="second-level"><a href="#introduccion">Introducción</a></li>
                
            <li class="second-level"><a href="#como-continuar">Como continuar</a></li>
                
            <li class="second-level"><a href="#practica">Práctica</a></li>
                
                <li class="third-level"><a href="#primera-comunicacion-i2c">Primera comunicación I2C</a></li>
                <li class="third-level"><a href="#leer-un-byte">Leer un byte</a></li>
                <li class="third-level"><a href="#leer-de-una-direccion-concreta">Leer de una dirección concreta</a></li>
                <li class="third-level"><a href="#leer-un-bloque-de-memoria">Leer un bloque de memoria</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="practica-2-el-bus-i2c">Práctica 2 - El bus I2C</h1>
<h2 id="introduccion">Introducción</h2>
<p>Antes de comenzar, se debe entender el concepto de bus:</p>
<blockquote>
<p>En arquitectura de computadores, el <strong>bus</strong> (o canal) es un sistema digital que transfiere datos entre los componentes de una computadora. Está formado por cables o pistas en un circuito impreso, dispositivos como resistores y condensadores, además de circuitos integrados.</p>
<p>Existen dos tipos de transferencia en los buses:</p>
<ul>
<li>Serie: El bus solamente es capaz de transferir los datos bit a bit. Es decir, el bus tiene un único cable que transmite la información.</li>
<li>Paralelo: El bus permite transferir varios bits simultáneamente, por ejemplo 8 bits.</li>
</ul>
<p>Aunque en primera instancia parece mucho más eficiente la transferencia en paralelo, esta presenta inconvenientes:</p>
<ul>
<li>La frecuencia de reloj en el bus paralelo tiene que ser más reducida.</li>
<li>La longitud de los cables que forman el bus está limitada por las posibles interferencias, el ruido y los retardo en la señal.</li>
</ul>
<p>Además, los modernos buses serie están formados por varios canales: En este caso se transmite por varios buses serie simultáneamente. </p>
<p><small><a href="https://es.wikipedia.org/wiki/Bus_(inform%C3%A1tica)">Wikipedia</a></small></p>
</blockquote>
<p>El <strong>bus I2C</strong> surge como una solución de comunicación entre los chips de un circuito y es una norma que especifica la velocidad, niveles de tensión, y el protocolo a seguir para conseguir dicha comunicación.</p>
<p>Se basa en una comunicación de tipo Maestro-Esclavo, donde varios chips se conectan entre si en paralelo, compartiendo las lineas de alimentación, Vcc y GND, y dos específicas, SCL (linea de reloj) y SDA (linea de datos).</p>
<p>Esto mismo se representa en la siguiente figura:</p>
<p><img alt="Diagrama de conexión I2C" src="I2C-diagram.jpg" /></p>
<p>El maestro, cuando quiera iniciar una comunicación, establecerá una frecuencia en la línea de SCL, que normalmente será 100 kHz o 400 kHz, e iniciará la comunicación como corresponda a traves de la linea SDA.</p>
<p>Dicha comunicación se hará localizada a un chip concreto, mediante su dirección de esclavo de 7 bits. Esto hace que el bus admita hasta 128 dispositivos.</p>
<p>Para no alargar la introducción entrando en detalles técnicos de nivel mas bajo, se facilita el documento oficial de NXP (antes Phillips) de especificaciones y uso del bus I2C. No será necesaria su lectura para la práctica, pero no está de mas tener a mano la documentación de cada parte para casos de duda, aprendizaje o pura curiosidad.</p>
<blockquote>
<p>Descargar <a href="UM10204.pdf"><i class="fa fa-cloud-download-alt" style="color:#FA023C"></i> I2C-bus specification and user manual (UM10204)</a></p>
</blockquote>
<h2 id="como-continuar">Como continuar</h2>
<p>Lo siguiente será informarse del manejo y control del bus I2C desde el punto de vista de Arduino, quien abstraerá todo el bajo nivel a modo de funciones incluidas mediante librerías.</p>
<blockquote>
<p>El uso de librerias y trabajo de terceros es una practica habitual y recomendada. Es una de las grandes virtudes de la comunidad Open Source y Arduino.</p>
<p>Hay una gama muy amplia de librerias que sirven para dar soporte a dispositivos, para crear funcionalidades nuevas, &hellip;</p>
<p>Se recomienda buscar, probar y sacar conclusiones para ver tanto la calidad como el posible uso.</p>
</blockquote>
<p>Dichas librerias pueden ser parte del conjunto estándar, incluido de serie al instalar Arduino, o pueden ser de terceros, como sucede con la librería que da soporte Arduino al chip <em>ESP8266</em> (de otro modo, no sería posible trabajar con el entorno de Arduino y la placa proporcionada).</p>
<p>Para poder usarlas es necesario leer su documentacion de antemano, que se compone de:</p>
<ol>
<li><strong>Librerias ESP8266 para Arduíno</strong>: Se debe consultar para saber como manejar los periféricos del micro.  <br />
<a href="https://arduino-esp8266.readthedocs.io/en/latest/libraries.html">https://arduino-esp8266.readthedocs.io/en/latest/libraries.html</a></li>
<li><strong>Librerias de Arduino</strong>: Una vez vistos los pormenores de la parte especifica para ESP8266, se debe consultar esta para conocer el manejo genérico en todos los Arduino.  <br />
<a href="https://www.arduino.cc/en/Reference/Libraries">https://www.arduino.cc/en/Reference/Libraries</a></li>
</ol>
<p>Como se indica, se recomienda primero ver la parte específica y luego la general, ya que tendrá preferencia en el momento de su uso. Esto pasa con la funcion <code>Wire.begin()</code>:</p>
<p><code>Wire.begin()</code> existe en ambas librerias y se llaman de forma diferente, lo que puede dar lugar a fallos y confusión aunque el programa sea totalmente correcto.</p>
<p>Lo correcto será usar <code>Wire.begin(0, 2)</code> como dicta la libreria del ESP8266: <a href="https://arduino-esp8266.readthedocs.io/en/latest/libraries.html#i2c-wire-library">Wire.begin(SDA_pin, SCL_pin)</a>. Esto arrancará el periférico I2C en modo maestro usando concrétamente esos pines.</p>
<p>Como en la libreria del ESP8266 no aparece ninguna otra referencia al bus I2C, el resto de funciones se usarán como dicta la libreria <code>Wire</code> de Arduino.</p>
<h2 id="practica">Práctica</h2>
<p>En esta práctica se busca conseguir una comunicación a traves del bus I2C con el dispositivo <a href="../../hardware/#sensor-bme280-temperatura-humedad-y-presion"><i class="fa fa-link" style="color:#FA023C"></i> BME280</a> acoplado al D1 Mini.</p>
<p>Para referencia, el montaje proporcionado equivale al siguiente esquemático:</p>
<p><img alt="D1-and-sensors.png" src="../../hardware/D1-and-sensors.png" /></p>
<h3 id="primera-comunicacion-i2c">Primera comunicación I2C</h3>
<p>Para poder comenzar con el uso de las funciones de I2C es necesario incluir la cabecera de la libreria <code>Wire</code>, al principio de nuestro programa, de la siguiente forma:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;
</code></pre>

<p>Incluir su inicialización en la sección de setup:</p>
<pre><code class="C">/* Single-pass function to configure the app */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* Start serial for output */
  Serial.begin(115200);
}
</code></pre>

<p>Y por último, pedir un dato a algún dispositivo esclavo en el bucle principal, mostrándolo por pantalla para saber que está bien:</p>
<pre><code class="C">/* Recurrent task, called forever */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Request data from slave with address 0x12 */
  Wire.requestFrom(0x12, 1);

  /* Receive the byte */
  uint8_t c = Wire.read();

  /* Send it to console/monitor */
  Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p>Al lanzar el programa no se llevará a cabo una comunicación válida por no existir un esclavo con la dirección <code>0x12</code>, lo que deja la duda de .. <em>entonces cual es la correcta?</em>.</p>
<p>Para responderla es necesario <strong>estudiar los dispositivos</strong>, documentandose sobre su funcionamiento y sus modos de trabajo, de forma que posteriormente se pueda programar la tarea siguiendo el flujo de trabajo establecido por el fabricante.</p>
<h3 id="leer-un-byte">Leer un byte</h3>
<p>En el caso del BME280, tras leer <a href="../../hardware/BME280_datasheet_en.pdf"><i class="fa fa-link" style="color:#FA023C"></i> su datasheet</a>, vemos como la dirección asociada será <code>0x76</code> o <code>0x77</code>, según si uno de sus pines está puesto a GND o a Vcc. En el caso de la placa de prácticas, este pin está en GND por lo que la dirección final queda como <code>0x76</code>.</p>
<p>Otro punto a tener en cuenta es que no se está controlando la disponibilidad de datos, y se pide su lectura como si esto fuera un hecho, pero lo cierto es que es posible que el dispositivo pueda tardar en responder.</p>
<p>Si se intenta leer cuando no hay dato, y cuando hay dato no se lee, se puede llegar al caso en el que los datos no estén sincronizados, o que incluso se pierdan. Para solventar esto, y leer solo si hay datos, existe la función <a href="https://www.arduino.cc/en/Reference/WireAvailable">Wire.available()</a>.</p>
<p>Incluyendo ambos cambios, nuestro nuevo programa quedaría como:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;

/* Single-pass function to configure the app */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* start serial for output */
  Serial.begin(115200);
}

/* Recurrent task, called forever */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Request data from slave with address 0x76 */
  Wire.requestFrom(0x76, 1);

  /* Wait for data to be available */
  while (Wire.available())
  {
    /* Receive the byte */
    uint8_t c = Wire.read();

    /* Send it to console/monitor */
    Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);
  }

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p><small><em>Ver sketch <a href="https://github.com/euroavia-sevilla/curso-c-arduino/tree/master/arduino/sketch/BME280_available-byte/BME280_available-byte.ino"><i class="fab fa-github" style="color:#FA023C"></i> BME280_available-byte.ino</a> en GitHub</em></small></p>
<p>El programa debería imprimir por puerto serie algo parecido a:</p>
<pre><code class="text">Ahoy! ESP8266 here!
---
Received byte: 0x03
Ahoy! ESP8266 here!
---
Received byte: 0x1E
Ahoy! ESP8266 here!
---
Received byte: 0x27
Ahoy! ESP8266 here!
---
Received byte: 0x41
</code></pre>

<p>Pasado un tiempo los bytes mostrados deben comenzar a repetirse, lo que indicará que estamos leyendo los datos del BME280 adecuadamente. Esto pasa porque su puntero interno se incrementa automáticamente con cada lectura, y se reinicia llegado a un tope.</p>
<h3 id="leer-de-una-direccion-concreta">Leer de una dirección concreta</h3>
<p>Si nos fijamos bien, en el ejemplo anterior no estamos controlando qué dato pedimos, simplemente &ldquo;leemos un byte&rdquo;.</p>
<p>Para poder pedir un dato de una dirección concreta es necesario direccionarlo primero. De nuevo <a href="../../hardware/BME280_datasheet_en.pdf"><i class="fa fa-link" style="color:#FA023C"></i> su datasheet</a> detalla cómo leer y escribir un dato, de donde se extrae la siguiente figura, que representa la forma general de leer varios bytes de direcciones consecutivas.</p>
<p><img alt="BME280_read-addressing.png" src="BME280_read-addressing.png" /></p>
<p>Interpretándola, será necesario:</p>
<ol>
<li>Hacer una escritura, en la que el dato enviado será la dirección de la que queremos leer</li>
<li>El BME280 internamente reposicionará su puntero de memoria.</li>
<li>Entonces se procede a la lectura</li>
<li>Ahora es cuando el BME280 devolverá los datos almacenados a partir de la dirección pedida</li>
</ol>
<p>Si en lugar de varios queremos un único byte, simplemente tendremos que pedir un único byte <i class="far fa-smile"></i>.</p>
<blockquote>
<p>Para confirmar la comunicación se suele leer primero un byte conocido, que para el caso del BME280 es el identificador del chip, o <strong>Chip ID</strong>, localizado en la dirección <code>0xD0</code>.</p>
<p><small><a href="../../hardware/#sensor-bme280-temperatura-humedad-y-presion">Ver la sección dedicada al BME280</a> para mas información</small></p>
</blockquote>
<p>Si todo esto se traduce a código, lo visto quedaría como:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;

/*
 * Single-pass function to configure the app
 */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* start serial for output */
  Serial.begin(115200);
}

/*
 * Recurrent task, called forever
 */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Tell the BME280 where we want to read */
  Wire.beginTransmission(0x76);
  Wire.write(0xD0);
  Wire.endTransmission();

  /* Request data from slave with address 0x76 */
  Wire.requestFrom(0x76, 1);

  /* Wait for data to be available */
  while (Wire.available())
  {
    /* Receive the byte */
    uint8_t c = Wire.read();

    /* Send it to console/monitor */
    Serial.printf(&quot;Received byte: 0x%02X\n&quot;, c);
  }

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p><small><em>Ver sketch <a href="https://github.com/euroavia-sevilla/curso-c-arduino/tree/master/arduino/sketch/BME280_byte-addressing/BME280_byte-addressing.ino"><i class="fab fa-github" style="color:#FA023C"></i> BME280_byte-addressing.ino</a> en GitHub</em></small></p>
<p>El programa debería imprimir por puerto serie exáctamente lo siguiente:</p>
<pre><code class="text">Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
Ahoy! ESP8266 here!
---
Received byte: 0x60
</code></pre>

<p>Que indicará que se ha leído correctamente el identificador de chip, localizado en la dirección <code>0xD0</code>, con el valor esperado de <code>0x60</code>.</p>
<h3 id="leer-un-bloque-de-memoria">Leer un bloque de memoria</h3>
<p>Siguiendo la misma linea del ejemplo anterior, lo lógico sería pensar en hacer varios <code>Wire.read()</code> y salvar el resultado, algo como:</p>
<pre><code class="C">(...)
  /* Request data from slave with address 0x76 */
  Wire.requestFrom(0x76, 3);

  /* Wait for data to be available */
  while (Wire.available())
  {
    /* Receive the byte */
    uint8_t c0 = Wire.read();
    uint8_t c1 = Wire.read();
    uint8_t c2 = Wire.read();

    /* Send it to console/monitor */
    Serial.printf(&quot;Received bytes: 0x%02X, 0x%02X and 0x%02X\n&quot;, c0, c1, c2);
  }
(...)
</code></pre>

<p>Pero resulta un método tedioso y muy poco eficiente, en el que un bloque simple de 128 bytes sería un programa enorme para una tarea muy sencilla.</p>
<p>En este momento entran en juego los <code>arrays</code>, que son matrices compuestas por un numero finito de elementos de algún tipo definido. Para este caso se deberá usar un array de elementos de tipo <code>uint8_t</code>.</p>
<p>Junto al array, se utilizará una variable secundaria que servirá de índice para almacenar la posición dentro del array donde se salvará el siguiente dato. Esta variable comenzará siendo 0 y se incrementará cada vez que se reciba un dato.</p>
<p>Ahora queda saber desde qué dirección comenzar a leer, y para esto el datasheet proporciona el mapa de registros en memoria y sus direcciones, como se ve en la siguiente figura:</p>
<p><img alt="BME280_memory-map.png" src="BME280_memory-map.png" /></p>
<p>Como se puede observar, el primer dato se encuentra en la dirección <code>0x88</code> y el último en la <code>0xFE</code>, sumando un total de 118 bytes.</p>
<blockquote>
<p>Arduino tiene un limite interno para <code>Wire.requestFrom()</code> de <strong>128 bytes</strong>, y como se necesitan sólo 118 no debería haber problema, pero hay que tenerlo en cuenta en caso de necesitarse transferencias de mayor tamaño, ya que habría que fraccionarlas.</p>
</blockquote>
<p>Llevado a código, el nuevo programa podría quedar como sigue:</p>
<pre><code class="C">/* Include required headers and/or libraries */
#include &lt;Wire.h&gt;

#define SLAVE_ADDRESS 0x76
#define BLOCK_ADDRESS 0x88
#define BLOCK_LENGTH 118

/*
 * Single-pass function to configure the app
 */
void setup()
{
  /* Join i2c bus (address optional for master) */
  Wire.begin(0, 2);

  /* start serial for output */
  Serial.begin(115200);
}

/*
 * Recurrent task, called forever
 */
void loop()
{
  /* Welcome message! Useful as a control point */
  Serial.printf(&quot;Ahoy! ESP8266 here!\n---\n&quot;);

  /* Tell the BME280 where we want to read */
  Wire.beginTransmission(SLAVE_ADDRESS);
  Wire.write(BLOCK_ADDRESS);
  Wire.endTransmission();

  /* Use static to prevent block re-allocation on each pass */
  static uint8_t memory_map[BLOCK_LENGTH] = { 0x00 };

  /* Array index, stores position to write a received byte */
  uint8_t memory_idx = 0;

  /* Used to check the received amount */
  uint8_t rx_bytes = 0;

  /* Request data from slave */
  Wire.requestFrom(SLAVE_ADDRESS, BLOCK_LENGTH);

  /* Wait for data to be available */
  while (rx_bytes == 0)
  {
    rx_bytes = Wire.available();
  }

  /* Save the block */
  for (memory_idx = 0; memory_idx &lt; rx_bytes; memory_idx++)
  {
    memory_map[memory_idx] = Wire.read();
  }

  /* Print the block */
  Serial.printf(&quot; ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n&quot;);
  Serial.printf(&quot;----+------------------------------------------------&quot;);
  for (memory_idx = 0; memory_idx &lt; rx_bytes; memory_idx++)
  {
    /* Create a new line each 16 printed bytes */
    if ((memory_idx % 16) == 0)
    {
      Serial.printf(&quot;\n %02X |&quot;, memory_idx + BLOCK_ADDRESS);
    }

    /* Print a byte */
    Serial.printf(&quot; %02X&quot;, memory_map[memory_idx]);
  }
  Serial.printf(&quot;\nEnd of data\n&quot;);

  /* Ensure not to flood with a huge amount of fast data */
  delay(500);
}
</code></pre>

<p><small><em>Ver sketch <a href="https://github.com/euroavia-sevilla/curso-c-arduino/tree/master/arduino/sketch/BME280_block-read/BME280_block-read.ino"><i class="fab fa-github" style="color:#FA023C"></i> BME280_block-read.ino</a> en GitHub</em></small></p>
<p>En este ejemplo se ha incluido el uso de macros de precompilacion, como por ejemplo pasa con <code>#define BLOCK_LENGTH 118</code>.</p>
<p>Esto crea <code>BLOCK_LENGTH</code>, que parece y funciona como una variable ya que se sustituye por el numero 118, pero que se sustituye <strong>antes</strong> de compilar el programa, por lo que es como si se escribiera el numero 118 en el propio código.</p>
<ul>
<li><strong>Macro frente a Variable:</strong> La diferencia es que al tratarse de un valor constante, pues 118 no cambiará nunca a lo largo del programa, usar una variable para esto es un malgasto de memoria RAM.</li>
<li><strong>Macro frente a Número:</strong> La diferencia es que el uso de un nombre descriptivo frente a un simple numero siempre será mas claro de leer y de entender. El uso de números sin descripción es una mala práctica, y debe evitarse siempre que sea posible. Se conoce tambien como &lsquo;hardcoding&rsquo; o &lsquo;magic numbers&rsquo;:    <blockquote>
<p>In computer programming, the term <em>magic number</em> has multiple meanings. It could refer to one or more of the following:</p>
<ul>
<li><strong>Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants</strong></li>
<li>A constant numerical or text value used to identify a file format or protocol; for files, see List of file signatures</li>
<li>Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., Globally Unique Identifiers)</li>
</ul>
<p><small><a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">Wikipedia</a></small></p>
</blockquote>
</li>
</ul>
<p>El programa debería imprimir por puerto serie algo parecido a:</p>
<pre><code class="text">Ahoy! ESP8266 here!
---
 ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----+------------------------------------------------
 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE
 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00
 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02
 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00
 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00
 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E
 E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80
 F8 | 00 00 80 00 00 80
End of data
Ahoy! ESP8266 here!
---
 ++ | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
----+------------------------------------------------
 88 | B7 6E DD 67 32 00 79 92 3E D6 D0 0B 5F 28 D7 FE
 98 | F9 FF 0C 30 20 D1 88 13 00 4B A5 00 00 00 00 00
 A8 | 00 00 00 00 33 00 00 C0 00 54 00 00 00 00 60 02
 B8 | 00 01 FF FF 1F 60 03 00 00 00 00 FF 00 00 00 00
 C8 | 00 00 00 00 00 00 00 00 60 00 00 00 00 00 00 00
 D8 | 00 00 00 00 00 00 00 00 00 56 01 00 17 20 03 1E
 E8 | 27 41 FF FF FF FF FF FF FF 00 00 00 00 00 00 80
 F8 | 00 00 80 00 00 80
End of data
</code></pre>

<p>Como puede comprobarse, el <em>Chip ID</em> puede leerse como <code>60</code> en la posición con fila <code>C8</code> y columna <code>08</code> (que se corresponde a <em>0xC8 + 0x08 = 0xD0</em>, la dirección del Chip ID).</p></div>
        
        
    </div>

    <footer class="col-md-12 text-center">
        
        <hr>
        <p>
        <small>2019 - CieNTi - Euroavia Sevilla<br></small>
        
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>

        
        
    </footer>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '../..';
    </script>
    <script src="../../js/base.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
